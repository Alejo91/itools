#!/usr/bin/env python
# -*- coding: UTF-8 -*-
# Copyright (C) 2006 Juan David Ibáñez Palomar <jdavid@itaapy.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA

# Import from the Standard Library
from optparse import OptionParser
from string import Template

# Import from itools
import itools


def wrap(text, width=72, indent='  '):
    # Clean text
    text = text.strip()
    lines = [ x.strip() + '\n' for x in text.splitlines() ]
    text = ''.join(lines)
    # Split paragraphs
    paragraphs = []
    for paragraph in text.split('\n\n'):
        words = paragraph.split()
        word = words.pop(0)
        lines = [indent+word]
        while words:
            word = words.pop(0)
            if len(lines[-1]) + len(word) < width:
                lines[-1] += (' ' + word)
            else:
                lines[-1] += '\n'
                lines.append(indent + word)
        lines[-1] += '\n'
        paragraph = ''.join(lines)
        paragraph += '\n'
        paragraphs.append(paragraph)

    return ''.join(paragraphs)


text_template = Template(
"""$name

$doc

Public Programming Interface:

$api
""")


text_template_item = Template(
"""* $name

$doc
""")


latex_template = Template(
"""\\chapter{$name}
\\index{$name}
$doc

$api\n""")


latex_template_item = Template(
"""\\subsubsection{$name}
\\index{$name}
$doc

""")

def latex_escape(x):
    return x.replace('_', '\\_').replace('#', '\#')


def text(namespace, template1, template2, escape=lambda x: x):
    if namespace['api']:
        api = [ template2.substitute(x) for x in namespace['api'] ]
        namespace['api'] = ''.join(api)
    else:
        default = 'THIS PACKAGE HAS NOT DEFINED A PUBLIC API.\n\n'
        namespace['api'] = wrap(default)

    out = template1.substitute(namespace)
    return escape(out)



def build_namespace(pkg):
    namespace = {}
    # Package name
    namespace['name'] = pkg.__name__
    # Documentation String
    doc = pkg.__doc__
    if doc is None:
        doc = 'THIS PACKAGE HAS NOT A DOCUMENTATION STRING.'
    namespace['doc'] = wrap(doc)
    # Public API
    all = pkg.__all__
    if all is None:
        all = []

    all.sort(key=lambda x: x.lower())
    api = []
    for name in all:
        doc = getattr(pkg, name).__doc__
        if doc is None:
            doc = 'THIS OBJECT HAS NOT A DOCUMENTATION STRING.'
        else:
            doc = doc.strip()
        doc = wrap(doc)
        api.append({'name': name, 'doc': doc})

    namespace['api'] = api
    return namespace



if __name__ == '__main__':
    # The command line parser
    usage = '%prog [OPTIONS] PACKAGE'
    version = 'itools %s' % itools.__version__
    description = 'Extract documentation from the given package.'
    parser = OptionParser(usage, version=version, description=description)
    parser.add_option('-f', '--format',
        help='the output FORMAT (defaults to text)')

    options, args = parser.parse_args()
    if len(args) != 1:
        parser.error('incorrect number of arguments')

    # Find out the format
    format = options.format
    if not format:
        format = 'text'

    # Action
    exec('import %s as pkg' % args[0])
    namespace = build_namespace(pkg)
    if format == 'text':
        print text(namespace, text_template, text_template_item)
    elif format == 'latex':
        print text(namespace, latex_template, latex_template_item,
                   latex_escape)
    else:
        raise ValueError
