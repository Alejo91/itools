\chapter{Internationalization and Localization}
\label{Chapter: i18n}

The task tracker from the previous chapter provides a user interface in
only one language: English. The purpose of this chapter is to explain how
to build applications that provide a user interface in many languages.
We will illustrate this building up on the task tracker example.

See the file layout of the already multilingual task tracker:

\begin{code}
    Makefile
    TaskTracker.py
    TaskTracker_view.xml.en
    locale/
      locale.pot
      en.po
      es.po
\end{code}

There are two things to note. First the {\tt locale} directory: it is
a database which keeps the translations for the text messages of the user
interface. The translations are stored in {\em PO}\footnote{XXX} files;
there is one {\em PO} file for every language, in our example there is
one for English ({\tt en.po}) and another for Spanish ({\tt es.po}). Each
{\em PO} file keeps the source messages, usually written in English, and
their translations (because the source language is English, the {\tt en.po}
file will be usually empty).

The second thing to note is the {\tt Makefile}, it will help us to automatize
the localization and build processes. The Figure~\ref{Figure: l10n} shows
these two processes.

\begin{figure}
  \center
  \includegraphics[width=\textwidth]{l10n.eps}
  \caption{The localization process}
  \label{Figure: l10n}
\end{figure}


\section{Internationalization}

Internationalization:

\begin{quote}
  \em
  the operation by which a program, or a set
  of programs turned into a package, is made aware of and able to support
  multiple languages.
\end{quote}

The text messages to translate are stored in the XML templates and the Python
code, so these are the two things to internationalize.

\subsection{Python code}

To start our task tracker must be {\em domain aware}:

\begin{code}
    from itools.gettext.domains import DomainAware

    class TaskTracker(Text, DomainAware):

        class_domain = 'task tracker'
\end{code}

The class {\tt DomainAware} provides the application programming interface
we will use within the Python code:

\begin{api}
  {\tt gettext(message, language=None, domain=None)}\\
  - Returns the translation for the given message in the given language,
    from the given domain. If there is not a translation the same message
    is returned. If no language is given the method {\tt select\_language}
    will be called to choose one from the languages available in the
    domain. By default the domain used is the one specified in the class
    variable {\tt class\_domain}.

  {\tt select\_language(languages)}\\
  - Chooses and returns a language from the given list of languages. The
    default implementation uses the environment variable {\tt LANGUAGE}.
\end{api}

Now we just need to replace every text string in the source code by a
call to {\tt gettext}, for example:

\begin{code}
\end{code}


\subsubsection{Deferred translations}




\subsection{Templates}



Basically we need to be able to output the text messages in the language
the user prefers. These text messages may be found in two places, the
XML templates and the Python code.

We assume the text messages are first written in English, and then translated
from English to whatever languages we want. This means that we need 

Altogether with the code and the templates we will distribute the translations


\section{Localization}

Localization:

\begin{quote}
  \em
  the operation by which, in a set of programs already internationalized,
  one gives the program all needed information so that it can adapt itself
  to handle its input and output in a fashion which is correct for some
  native language and cultural habits.
\end{quote}





\section{Internationalization}

What must be internationalized is the user interface, what in our example
is reduced to the template {\tt addressbook\_view.xml}.

\subsection{Naming conventions}

The technique we use with {\tt itools} requires to have one template per
language, being english the master language. Each template must have a
distinct name, we will achieve it by appending the language code to the
end of the file:

\begin{code}
    addressbook_view.xml.en
    addressbook_view.xml.es
    addressbook_view.xml.fr
    ...
\end{code}

So the first thing to do is to rename the file {\tt addressbook\_view.xml}
to {\tt addressbook\_view.xml.en}.

Note that only the template in English belongs to the source, the others
will be automatically built with the help of {\tt itools}.

\subsection{Template selection}

The method {\tt view} also must be modified, so the right template is used:

\begin{code}
    def view(self, language='en'):
        # Load the STL template
        resource_name = 'addressbook_view.xml.%s' % language
        resource = get_resource(resource_name)
        template = XML.Document(resource)

        ...
\end{code}


What remains to explain is how the application chooses the language the
user wants to see the addressbook in. This topic is out of the scope
of this chapter.

\section{Localization}

To illustrate the example we will use Spanish as the second language.

The issue is, from the template {\tt addressbook\_view.xml.en} we
must produce a template named {\tt addressbook\_view.xml.es}, where
the translatable messages will be in Spanish instead of English.

In our case there is only one translatable message, the word
{\tt Addressbook}. While the English template contains the header:

\begin{code}
    <h3>Addressbook</h3>
\end{code}

the Spansih one must have:

\begin{code}
    <h3>Libro de direcciones</h3>
\end{code}

The localization process is splitted in three stages:

\begin{enumerate}
  \item Message extraction.
  \item Human translation.
  \item Template re-construction.
\end{enumerate}

Through the whole process we will use {\tt GNU
gettext}\footnote{http://www.gnu.org/software/gettext/}, which is the
standard in the Free Software world for software internationalization
and localization; and the script {\tt igettext.py} provided by {\tt itools}.


\subsection{Message extraction}

This step consists on the parsing of the templates that define the user
interface (in our case the file {\tt addressbook\_view.xml.en}), the
extraction of the translatable messages they contain, and the building of
a {\em PO} file which will be the input for the human translator.

This all is done with the {\tt igettext.py} script:

\begin{code}
    $ python igettext.py --pot addressbook_view.xml.en > es.po
\end{code}

The result is the {\tt es.po} file, whose content will be:

\begin{code}
    msgid ""
    msgstr ""
    "Project-Id-Version: PACKAGE VERSION\n"
    "POT-Creation-Date: 2004-10-28 17:10+CET\n"
    "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
    "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
    "Language-Team: LANGUAGE <LL@li.org>\n"
    "MIME-Version: 1.0\n"
    "Content-Type: text/plain; charset=UTF-8\n"
    "Content-Transfer-Encoding: 8bit\n"

    #: addressbook_view.xml.en:0
    msgid "Addressbook"
    msgstr ""
\end{code}

The file consist of a header and the translatable messages that have been
found, in our case just the word {\tt Addressbook}. This file is the one
the translator will work with.


\section{Human translation}

The human translator receives the PO file, and must return the same PO
file, but including the translations for every message. In our example
he should return the file (excluding the header):

\begin{code}
    #: addressbook_view.xml.en:0
    msgid "Addressbook"
    msgstr "Libro de direcciones"
\end{code}

To do his work he may use a simple text editor like {\em vi} or {\em emacs}.
But typically he will use one of the PO graphic editors available, for
example:

\begin{itemize}
  \item KBabel, {\tt http://www.kde.org}
  \item poedit, {\tt http://poedit.sourceforge.net}
\end{itemize}


\section{Template building}

To close the process, we must generate the template
{\tt addressbook\_view.xml.es} from the master template
({\tt addressbook\_view.xml.en}) and from the translated PO file ({\tt es.po}).
This is done with the script {\tt igettext.py}:

\begin{code}
    $ igettext.py --xhtml addressbook_view.xml.en es.po \
          > addressbook_view.xml.es
\end{code}

And that's it, now we have the two templates, one in English and one in
Spanish.


