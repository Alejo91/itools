\chapter{Resource Handlers}

The resource layer knowledge about the {\em meaning} of the content of
a resource is minimal. For example, it does not know that an XML document
has a tree structure, hence it does not provide an API to traverse it; nor
it knows how to get the messages and translations from a PO file.

This is the purpose of the {\em resource handlers}, to add semantics to
specific resources.


\section{Building handlers}

Let's go straight with an example:

\begin{enumerate}
  \item First we load a resource as seen in the previous chapter:
\begin{code}
    >>> from itools.resources import get_resource
    >>> resource = get_resource('http://example.com')
\end{code}

  \item Now we build a handler for the resource:
\begin{code}
    >>> from itools.xml import HTML
    >>> handler = HTML.Document(resource)
    >>> print repr(handler)
    <itools.handlers.HTML.Document object at 0x40647b4c>
    >>> print handler
    <HTML>
    <HEAD>
      <TITLE>Example Web Page</TITLE>
    </HEAD> 
    <body>  
    <p>You have reached this web page by typing
    ...
\end{code}

  \item Now we can start working with the handler:
\begin{code}
    >>> from itools.xml import XML
    >>> for node in handler.traverse():
    ...     if isinstance(node, XML.Element) and node.name == 'title':
    ...         print node.children
    Example Web Page
\end{code}
\end{enumerate}



It is important to highlight that every handler has associated one and only
one resource, which is accessible through the {\tt resource} attribute:

\begin{code}
    >>> resource
    <itools.resources.http.File instance at 0x404aadec>
    >>> handler.resource
    <itools.resources.http.File instance at 0x404aadec>
    >>> resource is handler.resource
    True
\end{code}


\subsection{The {\tt get\_handler} shorthand}

There is a short way to load a handler (instead of loading first the resource
and then building the handler explicitly), the function {\tt get\_handler}:

\begin{api}
  {\tt get\_handler(uri)}\\
  - Loads the resource at the given uri, tries to guess its mimetype by
  different meanings (name extension, etc.), searches for a suitable
  handler class in the registry, builds and returns the handler for
  the resource.
\end{api}

Compare the explicit way seen before:

\begin{code}
    >>> from itools.resources import get_resource
    >>> from itools.xml import HTML
    >>>
    >>> resource = get_resource('http://example.com')
    >>> handler = HTML.Document(resource)
\end{code}

With the shorthand:

\begin{code}
    >>> from itools.handlers import get_handler
    >>>
    >>> handler = get_handler('http://example.com')
\end{code}

Note that there is chance {\tt get\_handler} chooses a handler class
different than the one you would like to use.

In the examples that follow we will use {\tt get\_handler} most of the
time.


\section{The handler skeleton}

We have seen in the previous sub-section that the handler constructor expects
one parameter: the resource it is meant to handle; and once the handler is
built the resource is always accessible with {\tt handler.resource}.

However, it is also possible to build a handler without passing it any
parameter; in this case a memory resource will be built on the fly, let's
see an example:

\begin{code}
    >>> from itools.xml import HTML
    >>> handler = HTML.Document()
    >>> handler
    <itools.handlers.HTML.Document object at 0x403ee12c>
    >>> handler.resource
    <itools.resources.memory.File instance at 0x40638e4c>
    >>> print handler
    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
    <html>
      <head>
        <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"></meta>
        <title></title>
      </head>
      <body></body>
    </html>
\end{code}

The default content of the resource depends on the handler, and it is called
the {\em handler skeleton}. The constructor also accepts arbitrary keyword
parameters:

\begin{code}
    >>> handler = HTML.Document(title='Hello World')
    >>> print handler
    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
    <html>
      <head>
        <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"></meta>
        <title>Hello World</title>
      </head>
      <body></body>
    </html>
\end{code}

The keyword parameters are used to initialize the skeleton, in the example
the {\tt title} parameter defines the HTML document title, which by default
is empty. The parameters accepted depend on the handler.



\section{Folders}

A handler that deserves its particular section is the default handler for
folders, whose core API is:

\begin{api}
  {\tt get\_handler(path)}\\
  - Returns a handler for the resource at the given path. It will use the
    available handler class that better matches the resource mimetype.

  {\tt set\_handler(path, handler)}\\
  - Adds the given handler to the given path. Actually what is added is
    the resource associated to the handler.

  {\tt del\_handler(path)}\\
  - Removes the handler at the given path (i.e. the associated resource).
\end{api}

An example will show it better.

\begin{enumerate}
  \item First we build a handler for the temporary directory:

\begin{code}
    >>> from itools.handlers import get_handler
    >>>
    >>> tmp = get_handler('/tmp')
    >>> tmp
    <itools.handlers.Folder.Folder object at 0x40652dec>
    >>> tmp.resource
    <itools.resources.file.Folder instance at 0x406acacc>
\end{code}

  \item Second, we create a new HTML handler:

\begin{code}
    >>> from itools.xml import HTML
    >>> hello = HTML.Document(title='Hello World')
    >>> hello.resource
    <itools.resources.memory.File instance at 0x405e49cc>
\end{code}

    Note that the associated resource is built on the fly and lives in memory.

  \item Third, we set the HTML handler to the temporary folder:

\begin{code}
    >>> tmp.set_handler('hello.html', hello)
\end{code}

    What this actually does is to add the file {\tt hello.resource} (which
    lives in memory) to the folder {\tt tmp.resource} (which is on the
    file system); this is to say, it creates a new file in the file system
    at {\tt /tmp/hello.html}.

  \item Finally, we get the handler we just added:

\begin{code}
    >>> hello = tmp.get_handler('hello.html')
    >>> hello.resource
    <itools.resources.file.File instance at 0x40638c6c>
\end{code}

    Note that the handler {\tt hello} we have built in these last lines
    manages a resource that lives in the file system.

\end{enumerate}



\subsection{The handler tree}

Folders allow to classify files, hence giving a tree structure to our data.
Every handler has two attributes, {\tt parent} and {\tt name}, they tell us
where the handler is in the handler tree:

\begin{code}
    >>> hello.parent
    <itools.handlers.Folder.Folder object at 0x403ebb2c>
    >>> hello.name  
    'hello.html'
    >>> hello.parent is tmp
    True
    >>> print tmp.parent
    None
    >>> print tmp.name

    >>> 
\end{code}

Based on these two attributes handlers provide the following API:

\begin{api}
  {\tt get\_abspath()}\\
  - Returns the absolute path from the tree root to the {\tt self} handler.

  {\tt get\_root()}\\
  - Returns the handler for the root of the tree.

  {\tt get\_pathtoroot()}\\
  - Returns a relative path from {\tt self} to the tree root (e.g.
    {\tt ../../..}).

  {\tt get\_pathto(handler)}\\
  - Returns a relative path from {\tt self} to the given handler (which is
    supposed to be in the same tree), for example: {\tt ../../zoo/lion}.

  {\tt traverse()}\\
  - This method allows to traverse the handler tree below this folder. It
    is a generator which returns a handler at a time, starting by this
    folder.

  {\tt acquire(name)}\\
  - If the current handler is a folder and contains a resource with the given
    name, then return a handler for it; otherwise look at the parent folder,
    and recursively to the root tree. This method actually shows how to
    implement {\em acquisition}.
\end{api}



\section{Overview of the available handlers}

What follows is a non exhaustive list of the resource handlers that
{\tt itools} includes out of the box, with the most relevant part of the API.

\paragraph{File}

This is the default handler for files, to be used when there is nothing
better. The API is really basic:

\begin{api}
  {\tt \_\_str\_\_}\\
  - Returns the resource data as a byte string (this is similar to the
    method {\tt handler.resource.get\_data()}).
\end{api}

\paragraph{Text}

The default handler for text files, whose API is:

\begin{api}
  {\tt \_\_unicode\_\_}\\
  - Returns the resource data as an unicode string.

  {\tt \_\_str\_\_}\\
  - Returns the resource data as a byte string, by default the used
  encoding is UTF-8. Note that this will be different than the string
  returned by {\tt handler.resource.get\_data()} if the resource data
  is not encoded in UTF-8 in the source.

  {\tt to\_str(encoding='UTF-8')}\\
  - Returns the resource data as a byte string, using the given encoding.
\end{api}

\paragraph{XML.Document}

This is the default handler for XML documents, which internally are
represented as a tree. The API includes the methods already described
for the {\tt Text} handler; specific methods of {\tt XML.Document} are:

\begin{api}
  {\tt \_\_cmp\_\_(other)}\\
  - Lets to compare two XML documents.

  {\tt get\_root\_element()}\\
  - Returns the root element of this XML document.

  {\tt traverse()}\\
  - This method allows to traverse the XML document, as it has a tree
    structure. It is a generator which returns a node at a time, starting
    by the document instance.

  {\tt walk(before=None, after=None, context=None)}\\
  - As {\tt traverse}, this method allows to traverse the XML document,
    though it is more powerful, and complex. It will be explained in the
    XML chapter.
\end{api}

Actually, the features provided by {\tt itools} to manage XML documents
are quite powerful, but beyond the scope of this article.

\paragraph{XHTML.Document}

The handler for XHTML documents, it extends the API provided by
{\tt XML.Document} API with the methods:

\begin{api}
  {\tt get\_head()}\\
  - Returns the head element.

  {\tt get\_body()}\\
  - Returns the body element.

  {\tt to\_text()}\\
  - Strips all the XML markup and returns the text content of the XHTML
    document. This is useful, for example, to index the document.
\end{api}

\paragraph{PO}

The handler to manage PO files, the message catalog of the GNU gettext
utilities.

\begin{api}
  {\tt get\_msgids()}\\
  - Returns the list of message ids stored in the catalog.

  {\tt get\_messages()}\\
  - Returns the list of messages stored in the catalog, where each message
    is represented as an instance of the class {\tt PO.Message}.

  {\tt get\_msgstr(msgid)}\\
  - Returns the message string for the given message id.

  {\tt set\_message(msgid, msgstr=[u''], comments=[u''], references=\{\})}\\
  - Adds a message (from the given parameters) to the catalog.
\end{api}

