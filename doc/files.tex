\chapter{File handlers}

Resources provide persistence to our data, but they lack any knowledge
about the structure and the meaning of the information they contain. For
example, the resource layer ignores that an XML document has a tree
structure, hence it does not provide an API to traverse it; nor it knows
how to get the messages and translations from a PO file.

This is the purpose of the {\em resource handlers}, to add semantics to
specific resources.

As with resources, there are two types of handlers, files and folders.
This first chapter focuses on file handlers, the next one will analyze
the folder handlers.

Several key concepts will be exposed in this chapter, the relationship
between resources and handlers, the load (de-serialization) and save
(serialization) operations, the handler skeleton, and the handler factory.
We will learn to use the file handlers {\tt itools} offers out of the box,
and how to write custom handler classes.


\section{Introduction}

To get a feeling, let's start with an example:

\begin{enumerate}
  \item First we load a resource as seen in the previous chapter:
\begin{code}
    >>> from itools.resources import get_resource
    >>> resource = get_resource('http://example.com')
\end{code}

  \item Now we build a handler for the resource:
\begin{code}
    >>> from itools.xml import HTML
    >>> handler = HTML.Document(resource)
    >>> print handler
    <itools.html.HTML.Document object at 0x40647b4c>
    >>> print handler.to_str()
    <HTML>
    <HEAD>
      <TITLE>Example Web Page</TITLE>
    </HEAD> 
    <body>  
    <p>You have reached this web page by typing
    ...
\end{code}

    There are several things to highlight here. First the way we have built
    our handler instance, passing a resource to a handler class
    ({\tt HTML.Document}), later we will see other ways to build handler
    instances.

    Second the {\tt to\_str} method (all the file handlers have this
    method), which serializes the handler, i.e. transforms the handler to
    a sequence of bytes. This is a key concept to which we will come back
    later.

  \item Now we can start working with the handler:
\begin{code}
    >>> from itools.xml import XML
    >>> for node in handler.traverse():
    ...     if isinstance(node, XML.Element) and node.name == 'title':
    ...         print node.children
    Example Web Page
\end{code}

   Unlike {\tt to\_str}, the method {\tt traverse} is specific to XML
   documents. Every handler class provides its own API.
\end{enumerate}


\subsubsection{One resource, many handlers}

The relationship between resources to handlers is {\em 1} to {\em n}.
While there may be several different handlers associated to the same
resource (though it is not obvious how this is useful), a handler is
only associated to one resource.

The resource associated to a handler is accessible through the {\tt resource}
attribute. Following the example above, the code below checks that the
resource we loaded in the first place is exactly the same our handler is
associated to:

\begin{code}
    >>> resource
    <itools.resources.http.File instance at 0x404aadec>
    >>> handler.resource
    <itools.resources.http.File instance at 0x404aadec>
    >>> resource is handler.resource
    True
\end{code}


\section{Handler's state}

A handler is a non-persitent object, it stores in volatile memory a data
structure that represents the resource's content. For example, the
Figure~\ref{Figure: state} shows at the left an XML file, and at the
right the state of the handler as a tree of XML elements.

\begin{figure}
  \center
  \includegraphics[width=\textwidth]{state.eps}
  \caption{Handler's state}
  \label{Figure: state}
\end{figure}

The state of a handler is stored within the instance variable {\tt state},
what this variable contains depends on the handler class; e.g. an element
tree for XML documents, a mapping from message to translation for PO files,
or just a unicode string for plain text files. For example:

\begin{code}
    >>> from itools.xhtml import XHTML
    >>> handler = XHTML.Document()
    >>> print handler
    <itools.xhtml.XHTML.Document object at 0xb7cae8ac>
    >>> print handler.state
    <itools.handlers.Handler.State object at 0xb7cae92c>
    >>>
    >>> from pprint import pprint
    >>> pprint(handler.state.__dict__.keys())
    ['xml_version',
     'source_encoding',
     'document_type',
     'root_element',
     'standalone']
\end{code}

The state variable should never be accessed directly, instead the API each
handler provides should be used.

We call {\em load} to the process of building the handler state from the
data stored in the resource. And viceversa, we call {\em save} to the
process of updating the resource with the changes made to the handler
state.

So, while the handler and the resource are synced inmediately after the
handler is loaded, this is to say, they contain the same information,
one or the other may change, hence becoming desynchronized. There are a
couple of scenarios we want to deal with:

\begin{itemize}
  \item Once the handler is loaded, the resource is modified by other
    means, for example you open the file with an editor and modify it.

    Then the handler is outdated, its state represents an older version
    of the resource.

  \item After loading the handler, its state is modified through the API
    it provides.

    Then the resource is outdated, as the handler contains a newer version
    of the information.
\end{itemize}



\subsection{Load}

It may happen that the resource (a web page in our example) gets updated, then
the handler will keep a data structure on memory that does not correspond
anymore to the content of the resource, in other words, the handler would
be out-of-date. We can check this by comparing the last modification time of
the resource with the timestamp every handler always keeps:

\begin{code}
    >>> print handler.resource.get_mtime()
    2004-11-28 19:53:57
    >>> print handler.timestamp
    2004-12-29 19:31:39.055367
    >>> handler.resource.get_mtime() > handler.timestamp
    False
\end{code}

Ok, the example above shows everything is alright. But what to do if it was
not? then we would need to reload the resource, this is done with the
{\tt load\_state} method:

\begin{code}
    >>> print handler.timestamp
    2004-12-29 19:31:39.055367
    >>> handler.load_state()
    >>> print handler.timestamp
    2004-12-29 19:51:50.152499
\end{code}

You should try it yourself with a resource in the filesystem: start the
Python interpreter, build a handler for a resource in the filesystem,
modify the resource with another program, see how the resource
modification time is more recent than the handler's timestamp, then reload
the handler and verify the handler is up-to-date now.

The full prototype of the method {\tt load\_state} follows:

\begin{api}
  {\tt load\_state(resource=None)}\\
  - Loads the data from the given resource into the handler, if no
    resource is given, the one the handler is attached to will be used.
\end{api}

As you see the {\tt load\_state} method accepts an optional parameter, a
resource. If it is not given the handler will be reloaded from the resource
it handles. But if other resource is passed it will be loaded from the given
resource. Then we would reach a situation opposite to the one seen before:
the resource would be outdated, as the handler would keep a newer version.


\subsection{Save}

Another way to get a handler more recent than the resource it is associated
with, is to modify the handler through the API it offers, which depends
on the handler class (e.g. the API of an XML handler is different from the
API of an image handler).

To update the resource so both resource and handler are in sync again we
use the {\tt save\_state} method:

\begin{api}
  {\tt save\_state()}\\
  - Saves the handler into the resource.
\end{api}

So {\tt load\_state} and {\tt save\_state} are two sides of the same coin.
The first one reloads the handler with the resource, the second one saves
the handler state in the resource.


\subsection{Serialization and de-serialization}

A file resource represents a sequence of bytes. A handler keeps a data
structure in memory, and offers an API to inspect and modify this data
structure.

Two key concepts in computer science will help to clarify what we have
seen up to now:

\begin{description}
  \item [serialization] is the process by which a sequence of bytes is
    transformed into a data structure.

  \item [de-serialization] is the process by which a data structure is
    transformed to a sequence of bytes.
\end{description}

Now it becomes obvious that the {\tt load\_state} method what actually
does is to de-serialize the resource and update the handler. And viceversa,
the {\tt save\_state} method serializes the handler and updates the resource.

Remember the method {\tt to\_str} we saw at the beginning? it is the one
responsible for the serialization process. The {\tt save\_state} method
calls {\tt to\_str} first, and then updates the resource.


\section{The skeleton}

As we have seen the handler constructor expects one parameter: the resource
it is meant to handle (and once the handler is built the resource is always
accessible with {\tt handler.resource}).

However, it is also possible to build a handler without passing it any
parameter; in this case a memory resource will be built on the fly, let's
see an example:

\begin{code}
    >>> from itools.html import HTML
    >>> handler = HTML.Document()
    >>> handler
    <itools.handlers.HTML.Document object at 0x403ee12c>
    >>> handler.resource
    <itools.resources.memory.File instance at 0x40638e4c>
    >>> print handler.to_str()
    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
      "http://www.w3.org/TR/html4/loose.dtd">
    <html>
      <head>
        <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
        <title></title>
      
      <body></body>
    </head></html>
\end{code}

The default content of the resource depends on the handler, and it is called
the {\em handler skeleton}. The constructor also accepts arbitrary keyword
parameters:

\begin{code}
    >>> handler = HTML.Document(title='Hello World')
    >>> print handler.to_str()
    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
    <html>
      <head>
        <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
        <title>Hello World</title>
      </head>
      <body></body>
    </html>
\end{code}

The keyword parameters are used to initialize the skeleton; in the example
above the {\tt title} parameter defines the HTML document title, which by
default is empty. The parameters accepted depend on the handler.


\section{Text and binary handlers}

File handlers split into text and binary handlers. The class {\tt Text}
is the base class for all the text handlers.

The key difference is that text handlers represent the resource's content
in memory as a unicode string, instead of just a byte string.

When the resource is loaded the text handler tries to guess the character
encoding of the resource's content. For some file formats this information
is stored within the content itself; for example an XML document starts
by an XML declaration that specifies the encoding, if the declaration is
missing it is assumed the encoding is UTF-8. When this information is not
explicitly indicated, the text handler tries to guess the encoding by
brute force.

With the character encoding the text handler decodes and loads the resource's
content.

The API of binary and text handlers also differs, compare the one offered
by the {\tt File} handler class:

\begin{api}
  {\tt to\_str()}\\
  - Returns the resource data as a byte string (this is similar to the
    method {\tt handler.resource.read()}).
\end{api}

with the one offered by the {\tt Text} handler class:

\begin{api}
  {\tt to\_str(encoding='UTF-8')}\\
  - Returns the resource data as a byte string, using the given encoding
  (defaults to {\tt UTF-8}). Note that this will be different than the
  string returned by {\tt handler.resource.read()} if the resource
  data is not encoded in {\tt UTF-8} in the source.

  {\tt to\_unicode(encoding='UTF-8')}\\
  - Returns the resource data as an unicode string.
\end{api}

Note the {\tt to\_str} method for text handlers accepts the encoding as
an optional parameter. This not only will return a byte string in the
given charater encoding, it will also specify the encoding in the byte
string for file formats that should include it.

There is also the new method {\tt to\_unicode}, which returns the content
as a unicode string. This method accepts the encoding parameter too. For
file formats that do not include the encoding within the content, the
result of {\tt to\_unicode} will be the same regardless of the given
encoding. But for file formats like XML that should specify the encoding
within the content, the returned unicode string will include it.



\section{Overview of the available handlers}

Out of the box {\tt itools} comes with several handlers for different
standard file formats. The Figure~\ref{Figure: handler tree} shows an
excerpt of the tree of the available handler classes, which express the
inheritance relationship between them.

\begin{figure}
  \center
  \includegraphics[height=\textwidth]{handlers.eps}
  \caption{The handler tree}
  \label{Figure: handler tree}
\end{figure}

We are not going to see folder handlers here, as they will be studied in
the next chapter.

We have already seen the difference between binary and text handlers. Now
we are going to present some of the higher level file handler classes
{\tt itools} includes.


\paragraph{XML.Document}

This is the default handler for XML documents, which internally are
represented as a tree. The API includes the methods already described
for the {\tt Text} handler; specific methods of {\tt XML.Document} are:

\begin{api}
  {\tt \_\_cmp\_\_(other)}\\
  - Lets to compare two XML documents.

  {\tt get\_root\_element()}\\
  - Returns the root element of this XML document.

  {\tt traverse()}\\
  - This method allows to traverse the XML document, as it has a tree
    structure. It is a generator which returns a node at a time, starting
    by the document instance.

  {\tt traverse2()}\\
  - As {\tt traverse}, this method allows to traverse the XML document,
    though it is more powerful, and complex. It will be explained in the
    XML chapter.
\end{api}

\paragraph{XHTML.Document}

The handler for XHTML documents, it extends the API provided by
{\tt XML.Document} API with the methods:

\begin{api}
  {\tt get\_head()}\\
  - Returns the head element.

  {\tt get\_body()}\\
  - Returns the body element.

  {\tt to\_text()}\\
  - Strips all the XML markup and returns the text content of the XHTML
    document. This is useful, for example, to index the document.
\end{api}

\paragraph{PO}

The handler to manage PO files, the message catalog of the GNU gettext
utilities.

\begin{api}
  {\tt get\_msgids()}\\
  - Returns the list of message ids stored in the catalog.

  {\tt get\_messages()}\\
  - Returns the list of messages stored in the catalog, where each message
    is represented as an instance of the class {\tt PO.Message}.

  {\tt get\_msgstr(msgid)}\\
  - Returns the message string for the given message id.

  {\tt set\_message(msgid, msgstr=[u''], comments=[u''], references=\{\})}\\
  - Adds a message (from the given parameters) to the catalog.
\end{api}


\section{The handler factory}

So far we have built a handler instance through a handler class:

\begin{code}
    >>> handler = HTML.Document(resource)
    >>> handler
    <itools.xml.HTML.Document object at 0x405740cc>
\end{code}

This is the standard pattern to build instances. However, if the resource
is not an HTML document this procedure would fail. In other words, this
procedure is only useful if you already know the kind of resource you
are working with.

Another option is to let {\tt itools} to choose which handler class to use.
This can be done with the {\tt build\_handler} method, which provides the
factory pattern.

\begin{api}
  {\tt build\_handler(resource)}\\
  - A class method that identifies the given resource, chooses the available
  handler class that better matches it, and builds and returns a handler
  instance for it.
\end{api}

For example, from the {\tt examples} directory type:

\begin{code}
    >>> from itools.resources import get_resource
    >>> from itools.handlers.Handler import Handler
    >>> from itools import xml
    >>> 
    >>> here = get_resource('.')
    >>> for name in here.get_resource_names():
    ...     resource = here.get_resource(name)
    ...     handler = Handler.build_handler(resource)
    ...     print name, handler
    ... 
    chapter6 <itools.handlers.Folder.Folder object at 0x40538d4c>
    chapter7 <itools.handlers.Folder.Folder object at 0x4032c0cc>
    hello.txt <itools.handlers.Text.Text object at 0x40536f4c>
    hello.xhtml <itools.xml.XHTML.Document object at 0x4053b70c>
\end{code}

Note that {\tt build\_handler} is a class method. In the example above
we have called it through the most abstract handler class: {\tt Handler},
which is the root of the inheritance tree. But it is also possible to call
it with another handler class:

\begin{code}
    >>> from itools.xml import XML
    >>> 
    >>> resource = here.get_resource('hello.xhtml')
    >>> XML.Document.build_handler(resource)
    <itools.xml.XHTML.Document object at 0x405c6ecc>
\end{code}

There is an important difference between calling {\tt build\_handler} from
one or another class: the set of possible handler classes to use is
restricted to all the sub-classes of the choosen handler class. For example,
if we pass a plain text file to {\tt XML.Document.build\_handler}, it will
fail:

\begin{code}
    >>> resource = here.get_resource('hello.txt')
    >>> XML.Document.build_handler(resource)
    Traceback (most recent call last):
      [...]
    xml.parsers.expat.ExpatError: syntax error: line 1, column 0
\end{code}


\subsection{The {\tt get\_handler} shorthand}

There is a short way to load a handler (instead of loading first the resource
and then building the handler explicitly), the function {\tt get\_handler}:

\begin{api}
  {\tt get\_handler(uri)}\\
  - Loads the resource at the given uri, tries to guess its mimetype by
  different meanings (name extension, etc.), searches for a suitable
  handler class in the registry, builds and returns the handler for
  the resource.
\end{api}

Compare the explicit way seen before:

\begin{code}
    >>> from itools.resources import get_resource
    >>> from itools.handlers.Handler import Handler
    >>>
    >>> resource = get_resource('http://example.com')
    >>> handler = Handler.build_handler(resource)
\end{code}

With the shorthand:

\begin{code}
    >>> from itools.handlers import get_handler
    >>>
    >>> handler = get_handler('http://example.com')
\end{code}