\chapter{Internationalization and Localization}
\label{Chapter: i18n}

The task tracker from the previous chapter provides a user interface in
only one language: English. The purpose of this chapter is to explain how
to build applications that provide a user interface in many languages.
We will illustrate this building up on the task tracker example.

See the file layout of the already multilingual task tracker:

\begin{code}
    Makefile
    TaskTracker.py
    TaskTracker_view.xml.en
    locale/
      locale.pot
      en.po
      es.po
\end{code}

There are two things to note. First the {\tt locale} directory: it is
a database which keeps the translations for the text messages of the user
interface. The translations are stored in {\em PO}\footnote{XXX} files;
there is one {\em PO} file for every language, in our example there is
one for English ({\tt en.po}) and another for Spanish ({\tt es.po}). Each
{\em PO} file keeps the source messages, usually written in English, and
their translations (because the source language is English, the {\tt en.po}
file will be usually empty).

The second thing to note is the {\tt Makefile}, it will help us to automatize
the localization and build processes. The Figure~\ref{Figure: l10n} shows
these two processes.

\begin{figure}
  \center
  \includegraphics[width=\textwidth]{l10n.eps}
  \caption{The localization process}
  \label{Figure: l10n}
\end{figure}


\section{Internationalization}

Internationalization:

\begin{quote}
  \em
  the operation by which a program, or a set
  of programs turned into a package, is made aware of and able to support
  multiple languages.
\end{quote}

The text messages to translate are stored in the XML templates and the Python
code, so these are the two things to internationalize.

\subsection{Python code}

To start, our task tracker must be {\em domain aware}:

\begin{code}
    from itools.gettext.domains import DomainAware

    class TaskTracker(Text, DomainAware):

        class_mimetypes = ['text/x-task-tracker']
        class_domain = 'task tracker'
\end{code}

Every application and library will have a unique domain name, this will
allow us to explicitly refer to a given domain to retrieve translations
from it. The domain name is specified with the class variable
{\tt class\_domain}.

By the way, we need to register the domain:

\begin{code}
    from itools import get_abspath
    from itools.gettext.domains import DomainAware, register_domain

    class TaskTracker(Text, DomainAware):

        class_mimetypes = ['text/x-task-tracker']
        class_domain = 'task tracker'

    ...

    domain_path = get_abspath(globals(), '../locale')
    register_domain(TaskTracker.class_domain, domain_path)
\end{code}

The class {\tt DomainAware} provides the application programming interface
we will use within the Python code:

\begin{api}
  {\tt get\_languages()}\\
  - Returns a list with the language codes of our application. By default it
    is not implemented, so it must be overriden by subclasses.

  {\tt select\_language(languages=None)}\\
  - Chooses and returns a language from the given list of languages. If the
    languages are not given, the method {\tt get\_languages} will be called
    to get them. The default implementation uses the environment variable
    {\tt LANGUAGE}.

  {\tt gettext(message, language=None, domain=None)}\\
  - Returns the translation for the given message in the given language,
    from the given domain. If there is not a translation the input message
    is returned. If no language is given the method {\tt select\_language}
    will be called to choose one from the languages available in the
    domain. By default the domain used is the one specified in the class
    variable {\tt class\_domain}.
\end{api}

Now we just need to replace every text string in the source code by a
call to {\tt gettext}, for example:

\begin{code}
    def show_open_tasks(self):
        for id, task in enumerate(self.state.tasks):
            if task.state == 'open':
                print self.gettext(u'Task #%(id)d: %(title)s') \
                      % {'id': id, 'title': task.title}
        ...
\end{code}

Note that we have used named arguments for the formatted string instead
of positional arguments. This is because the position of the arguments
may be different in another language.

The method {\tt gettext} not only will return the translation for the
given message, it also allows the message extraction script to detect
the messages that need to be translated.

\subsubsection{Deferred translations}

Sometimes we want to mark an string as translatable, so the message
extraction script finds it, but we don't want to translate it at run time.
This is done using a dummy function that just returns the given message:

\begin{code}
    from itools.gettext.domains import N_

    class TaskTracker(Text, DomainAware):

        class_domain = 'task tracker'
        class_title = N_(u'Task Tracker')
\end{code}

The function {\tt N\_} does nothing, it just returns the message it
receives. But allows the message extraction script to find it.


\subsection{Templates}


The technique we use with {\tt itools} requires to have one template per
language, being English the master language. Each template must have a
distinct name, we will achieve it by appending the language code to the
end of the file:

\begin{code}
    TaskTracker_view.xml.en
    TaskTracker_view.xml.es
\end{code}

Note that only the template in English belongs to the source, the others
will be automatically built with the help of {\tt itools}.

Now we are going to make some changes to the {\tt TaskTracker} class.
First we must override the method {\tt get\_languages}:

\begin{code}
    def get_languages(self):
        return ['en', 'es']
\end{code}

These are the languages of our task tracker, English and Spanish. Now we
must modify the {\tt view} method to choose the right template:

\begin{code}
    def view(self):
        # Load the STL template
        language = self.select_language()
        handler = get_handler('TaskTracker_view.xml.%s' % language)
        ...
\end{code}


\section{Localization}

Localization:

\begin{quote}
  \em
  the operation by which, in a set of programs already internationalized,
  one gives the program all needed information so that it can adapt itself
  to handle its input and output in a fashion which is correct for some
  native language and cultural habits.
\end{quote}





\subsection{Template selection}

The method {\tt view} also must be modified, so the right template is used:

\begin{code}
    def view(self, language='en'):
        # Load the STL template
        resource_name = 'addressbook_view.xml.%s' % language
        resource = get_resource(resource_name)
        template = XML.Document(resource)

        ...
\end{code}


What remains to explain is how the application chooses the language the
user wants to see the addressbook in. This topic is out of the scope
of this chapter.

\section{Localization}

To illustrate the example we will use Spanish as the second language.

The issue is, from the template {\tt addressbook\_view.xml.en} we
must produce a template named {\tt addressbook\_view.xml.es}, where
the translatable messages will be in Spanish instead of English.

In our case there is only one translatable message, the word
{\tt Addressbook}. While the English template contains the header:

\begin{code}
    <h3>Addressbook</h3>
\end{code}

the Spansih one must have:

\begin{code}
    <h3>Libro de direcciones</h3>
\end{code}

The localization process is splitted in three stages:

\begin{enumerate}
  \item Message extraction.
  \item Human translation.
  \item Template re-construction.
\end{enumerate}

Through the whole process we will use {\tt GNU
gettext}\footnote{http://www.gnu.org/software/gettext/}, which is the
standard in the Free Software world for software internationalization
and localization; and the script {\tt igettext.py} provided by {\tt itools}.


\subsection{Message extraction}

This step consists on the parsing of the templates that define the user
interface (in our case the file {\tt addressbook\_view.xml.en}), the
extraction of the translatable messages they contain, and the building of
a {\em PO} file which will be the input for the human translator.

This all is done with the {\tt igettext.py} script:

\begin{code}
    $ python igettext.py --pot addressbook_view.xml.en > es.po
\end{code}

The result is the {\tt es.po} file, whose content will be:

\begin{code}
    msgid ""
    msgstr ""
    "Project-Id-Version: PACKAGE VERSION\n"
    "POT-Creation-Date: 2004-10-28 17:10+CET\n"
    "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
    "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
    "Language-Team: LANGUAGE <LL@li.org>\n"
    "MIME-Version: 1.0\n"
    "Content-Type: text/plain; charset=UTF-8\n"
    "Content-Transfer-Encoding: 8bit\n"

    #: addressbook_view.xml.en:0
    msgid "Addressbook"
    msgstr ""
\end{code}

The file consist of a header and the translatable messages that have been
found, in our case just the word {\tt Addressbook}. This file is the one
the translator will work with.


\section{Human translation}

The human translator receives the PO file, and must return the same PO
file, but including the translations for every message. In our example
he should return the file (excluding the header):

\begin{code}
    #: addressbook_view.xml.en:0
    msgid "Addressbook"
    msgstr "Libro de direcciones"
\end{code}

To do his work he may use a simple text editor like {\em vi} or {\em emacs}.
But typically he will use one of the PO graphic editors available, for
example:

\begin{itemize}
  \item KBabel, {\tt http://www.kde.org}
  \item poedit, {\tt http://poedit.sourceforge.net}
\end{itemize}


\section{Template building}

To close the process, we must generate the template
{\tt addressbook\_view.xml.es} from the master template
({\tt addressbook\_view.xml.en}) and from the translated PO file ({\tt es.po}).
This is done with the script {\tt igettext.py}:

\begin{code}
    $ igettext.py --xhtml addressbook_view.xml.en es.po \
          > addressbook_view.xml.es
\end{code}

And that's it, now we have the two templates, one in English and one in
Spanish.


