\chapter{eXtensible Markup Language}

The purpose of this chapter is to explain the XML services provided by
{\tt itools}, which can be found in the sub-package {\tt itools.xml}.

\section{XML.Document}

The XML facilities provided by {\tt itools} are built upon the resource-handler
architecture. The basic handler class that enables us to manipulate XML files
is {\tt XML.Document}, now we are going to play a little bit with it:

\begin{code}
    >>> from itools.handlers import get_handler
    >>> import itools.xml
    >>>
    >>> doc = get_handler('examples/hello.xml')
    >>> doc
    <itools.xml.XML.Document object at 0x4064466c>
    >>> print doc.xml_version
    1.0
    >>> print doc.standalone 
    -1
    >>> print doc.document_type
    None
    >>> print doc.root_element
    <itools.xml.XML.Element object at 0xb7a3272c>
\end{code}

The code above shows the four attributes that keep the document's state:

\begin{api}
    {\tt xml\_version}\\
    - The XML version of the document, usually it is {\tt 1.0}.

    {\tt standalone}\\
    - Possible values are: {\tt 1} if the document was declared standalone,
      {\tt 0} if it was declared not to be standalone, or {\tt -1} if the
      standalone clause was omitted.

    {\tt document\_type}\\
    - If the document lacks a document type declaration this attribute will
      be {\tt None}. If the document type was specified this attribute will
      be a tuple with four values: the name, the system id, the public id
      and a boolean that tells wether the document contains an internal
      declaration subset.

    {\tt root\_element}\\
    - An instance of the {\tt XML.Element} class, the root of the DOM-like
      tree that represents the XML data, and that we will study later with
      more detail.
\end{api}


The API for the documents is rather simple:

\begin{api}
    {\tt get\_root\_element()}\\
    - Returns the root element.

    {\tt traverse()}\\
    - A generator that traverses the XML tree in pre-order, and returns
      each time a node. It is a shorthand for {\tt root\_element.traverse()}.

    {\tt traverse2()}\\
    - A more powerful version of {\tt traverse}. It is a shorthand for
      {\tt root\_element.traverse2()}.
\end{api}


\subsection{Inspecting the tree}

Coming back to the example, the {\tt examples/hello.xml} file's content is:

\begin{code}
    <?xml version="1.0" encoding="UTF-8"?>
    <html>
      <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Hello world</title>
        <!-- Changed by: , 02-Jun-2004 -->
      </head>
      <body>
      </body>
    </html>
\end{code}

The method {\tt traverse} lets us to easily inspect the tree nodes:

\begin{code}
    >>> for node in doc.traverse():
    ...     print repr(node)
    ... 
    <itools.xml.XML.Element object at 0xb7a3316c>
    u'\n  '
    <itools.xml.XML.Element object at 0xb7a331ac>
    u'\n    '
    <itools.xml.XML.Element object at 0xb7a332ac>
    u'\n    '
    <itools.xml.XML.Element object at 0xb7a331ec>
    u'Hello world'
    u'\n    '
    <itools.xml.XML.Comment object at 0xb7a335cc>
    u'\n  '
    u'\n  '
    <itools.xml.XML.Element object at 0xb798574c>
    u'\n  '
    u'\n'
\end{code}

Here we see the three kind of nodes currently supported: elements, comments
and text nodes.

\subsection{Elements}

Of the three kinds of nodes, elements are the most important and complex.
Element nodes give the tree structure, as they are the only ones that may
have children. If you inspect an element you will see the following
attributes:

\begin{api}
    {\tt namespace}\\
    - The XML namespace of the element (it will be None for a bare element).

    {\tt prefix}\\
    - The prefix used for the element's XML namespace.

    {\tt name}\\
    - The name of the element.

    {\tt attributes}\\
    - A dictionary mapping from the tuple XML namespace and local name to
      the attributes value.

    {\tt prefixes}\\
    - A mapping from XML namespace to prefix (used to get the qualified
      name of an attribute).

    {\tt children}\\
    - A list with the children of the element (elements, comments and text
      nodes).
\end{api}


And here is the API:

\begin{api}
    {\tt get\_qname()}\\
    - Returns the qualified name of the element.

    {\tt copy()}\\
    - Returns a clone of the element.

    {\tt set\_attribute(namespace, local\_name, value, prefix=None)}\\
    - Sets the given attribute.

    {\tt get\_attribute(namespace, local\_name)}\\
    - Returns the attribute value for the given XML namespace and local name.

    {\tt has\_attribute(namespace, local\_name)}\\
    - Returns a boolean value, true if the element contains a value for the
      given XML namespace and local name, false otherwise.

    {\tt get\_attributes()}
    - Is a generator that returns a three value tuple each time, the values
      are: XML namespace uri, local name, value.

    {\tt get\_attribute\_qname(namespace, local\_name)}\\
    - Returns the qualified name for the given XML namespace and local name.

    {\tt set\_element(element)}\\
    - Appends the given element to the list of children.

    {\tt set\_comment(comment)}\\
    - Appends the given comment to the list of children.

    {\tt set\_text(text)}\\
    - Appends the given text node (a unicode value) to the list of children.

    {\tt get\_elements(name=None)}\\
    - Returns a list with all the element nodes whose name is the given
    name; if the parameter {\tt name} is not given, then return all the
    element nodes.

    {\tt traverse()}\\
    - A generator that traverses the element's children in pre-order, and
      returns each time a node.

    {\tt traverse2()}\\
    - A more powerful version of {\tt traverse}.
\end{api}


\section{Namespaces}

One very important concept of XML are the {\em namespaces}.

An XML document may contain many different elements and attributes, if there
is not any XML declaration these elements and attributes will be instances
of the {\tt XML.Element} and {\tt XML.Attribute} classes, with the standard
API and none specific semantics.

But if there are namespace declarations, {\tt itools.xml} will be able to
build specific objects that add some special semantics. To see it we are
going to load the file {\tt examples/hello.xhtml}, whose content is:

\begin{code}
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
           "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml">
      <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Hello world</title>
        <!-- Changed by: , 02-Jun-2004 -->
      </head>
      <body>
      </body>
    </html>
\end{code}

The only two differences between this file and the example we saw at the
beginning ({\tt examples/hello.xml}) are the {\em document type} declaration
and, what interests us now, the XML namespace declaration:

\begin{code}
    xmlns="http://www.w3.org/1999/xhtml"
\end{code}

What this sentence says is that all the elements and attributes within the
document belong to the XHTML namespace. This information lets the {\tt itools}
XML parser to build a more ``intelligent'' tree:

\begin{code}
    >>> resource = get_resource('examples/hello.xhtml')
    >>> doc = XML.Document(resource)
    >>> 
    >>> doc
    <itools.xml.XML.Document object at 0x405ea38c>
    >>> 
    >>> for node in doc.traverse():
    ...     print repr(node)
    ... 
    <itools.xml.XHTML.Element object at 0xb7a3316c>
    u'\n  '
    <itools.xml.XHTML.Element object at 0xb7a331ac>
    u'\n    '
    <itools.xml.XHTML.Element object at 0xb7a332ac>
    u'\n    '
    <itools.xml.XHTML.Element object at 0xb7a33f2c>
    u'Hello world'
    u'\n    '
    <itools.xml.XML.Comment object at 0xb798554c>
    u'\n  '
    u'\n  '
    <itools.xml.XHTML.Element object at 0xb79855ac>
    u'\n  '
    u'\n'
\end{code}

Now, the element nodes are not any more instances of {\tt XML.Element}, but
instances of {\tt XHTML.Element}, which extends the generic API with the
methods:

\begin{api}
    {\tt is\_inline()}\\
    - Returns {\tt True} if the element is an inline element, {\tt False}
    otherwise.

    {\tt is\_block()}\\
    - Returns {\tt True} if the element is a block element, {\tt False}
    otherwise.
\end{api}

Ok, not too much\footnote{These two methods, {\tt is\_inline} and
{\tt is\_block}, are actually really useful. They are used by the message
extraction algorithm, a fundamental brick of the internationalization and
localization services provided by {\tt itools}.}, but enough to give an
idea of the power of {\tt itools.xml}. In the next chapter we will see a
much more compelling example of what can be done with {\tt itools.xml},
the {\bf S}imple {\bf T}emplate {\bf L}anguage.


