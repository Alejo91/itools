\chapter{Simple Template Language}

{\bf STL} is a template language. It is implemented as an XML namespace
handler, taking advantage of the underlying infrastructure provided by
{\tt itools.xml}.

{\bf STL} process and transforms XML files. It is aimed at presentation,
for example to produce the web pages that make up the user interface of
a web application.


\section{A descriptive language}

Unlike other template languages in the Python world, {\bf STL} does not
mix Python code within the template. The {\bf STL} statements only describe
the transformations to be performed on the template.

This way the logic and the presentation are really separated.

There are always two sides: the {\em template}, which represents the
presentation side; and the {\em namespace}, the logic side.

In five words: {\bf STL} is a {\em descriptive} language.

\subsection{The template}

For example, look at the template below (see {\tt example/template.xml}):

\begin{code}
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE html
         PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml"
          xmlns:stl="http://xml.itools.org/namespaces/stl">
      <head></head>
      <body>
        <h1 stl:content="title" />
      </body>
    </html>
\end{code}

Note the declaration of the {\em stl} namespace.

When this template will be processed, the content of the {\tt <h1>} tag
will be replaced by the value of the variable {\tt title}. But, where will
we find {\tt title}? Solution: in the namespace.

\subsection{The namespace}

In order to process an {\bf STL} template, you need to pass it a Python
namespace. But first we have to load the template as a handler:

\begin{code}
    >>> from itools.resources import get_resource
    >>> from itools.xml import XML
    >>>   
    >>> resource = get_resource('examples/template.xml')
    >>> template = XML.Document(resource)
    >>> 
    >>> template
    <itools.xml.XML.Document object at 0x405ea38c>
\end{code}

Note that so far nothing delates the {\bf STL} presence, but inspecting
the {\tt template} object shows that the {\em stl} namespace handler has
been loaded:

\begin{code}
    >>> template.stl
    <itools.xml.STL.STL object at 0x406516cc>
\end{code}

Ok, it is time to build the namespace and process the template:

\begin{code}
    >>> namespace = {'title': 'hello world'}
    >>> print template.stl(namespace)
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE html
         PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html xmlns:stl="http://xml.itools.org/namespaces/stl"
          xmlns="http://www.w3.org/1999/xhtml">
      <head></head>
      <body>
        <h1>hello world</h1>
      </body>
    </html>
\end{code}


As this example shows, the value of the variable {\tt title} is looked within
the namespace passed as parameter to {\tt template.stl}.


\section{Example: an addressbook}

Let's see a more complex example. The template below shows a simple
adressbook (see {\tt examples/addressbook.xml}):

\begin{code}
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE html
         PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml"
          xmlns:stl="http://xml.itools.org/namespaces/stl">
      <head></head>
      <body>
        <h3>Addressbook</h3>
        <ul>
          <li stl:repeat="address addressbook">
            <stl:block content="address/last_name" />,
            <stl:block content="address/first_name" />:
            <stl:block content="address/telephone" />
          </li>
        </ul>
      </body>
    </html>
\end{code}

The first new thing this example shows is the {\tt repeat} statement. While
{\tt stl:content} expects an string as the value, {\tt stl:repeat} expects
a sequence. When this template is processed, the XML output will contain as
many {\tt <li>} elements as items are in the {\tt addressbook} variable.
Within the element, in each iteration over the {\tt addressbook} sequence,
the variable {\tt address} will be the respective item of the list.

The second new thing we see is the {\tt <stl:block>} element. When the
template is processed the {\tt <stl:block>} tags are automatically
removed.

Finally, look at the expression {\tt address/last\_name}, it shows the {\em
slash} operator, which lets to traverse namespaces. So the variable {\tt
address} is expected to be a dictionary, and {\tt last\_name} a key in that
mapping, whose value is an string.

\subsubsection{The Python side}

Now let's see the Python code (in the script {\tt examples/addressbook.py}),
this time as a class which keeps the addressbook information, with a method
that process the template to produce an HTML page that shows the addressbook.

\begin{code}
    # Import from itools
    from itools.resources import get_resource
    from itools.xml import XML


    class Addressbook(object):
        def __init__(self):
            self.addresses = []


        def add_address(self, last_name, first_name, telephone):
            address = {'last_name': last_name,
                       'first_name': first_name,
                       'telephone': telephone}
            self.addresses.append(address)


        def view(self):
            # Load the STL template
            resource = get_resource('addressbook.xml')
            template = XML.Document(resource)

            # Build the namespace
            namespace = {'addressbook': self.addresses}

            # Process the template and return the output
            return template.stl(namespace)
\end{code}

The end of the module creates an {\tt Addressbook} instance, fills it with
a couple of entries and prints the result of the {\tt view} method:

\begin{code}
    if __name__ == '__main__':
        # Create the addressbook
        addressbook = Addressbook()
        addressbook.add_address('Jordan', 'Robert', '0606060606')
        addressbook.add_address('Buendia', 'Aureliano', '0612345678')

        # Output the addressbook content
        print addressbook.view()
\end{code}

The output of running this program is:

\begin{code}
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE html
         PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html xmlns:stl="http://xml.itools.org/namespaces/stl"
          xmlns="http://www.w3.org/1999/xhtml">
      <head></head>
      <body>
        <h3>Addressbook</h3>
        <ul>
          <li>
            Jordan,
            Robert:
            0606060606
          </li><li>
            Buendia,
            Aureliano:
            0612345678
          </li>
        </ul>
      </body>
    </html>
\end{code}


\section{Language overview}

So far we have seen {\tt stl:content} and {\tt stl:repeat}. Below is the
summary with all the {\bf STL} statements:

\begin{api}
    {\tt content}=``{\em expression}''\\
    - Replaces the element's content by the result of evaluating the given
    {\bf STL} expression.

    {\tt attributes}=``{\em name expression} [; {\em name expression}]*''\\
    - For every pair ``{\em name: expression}'', replace the the value of
    the attribute {\em name} by the result of evaluating {\em expression}.

    {\tt if}=``{\em expression}''\\
    - If the given expression evaluates to {\tt True}, do nothing; if
    evaluates to {\tt False}, remove the XML element.

    {\tt ifnot}=``{\em expression}''\\
    - If the given expression evaluates to {\tt False}, do nothing; if
    evaluates to {\tt True}, remove the XML element.

    {\tt repeat}=``{\em name expression}''\\
    - The given expression is expected to be a sequence or an iterator.
    For every item in {\em expression}, create an element and add the
    item to the namespace stack before processing the element.
\end{api}


\subsection{Expressions}

The {\bf STL} expressions are pretty simple, their syntax is:

\begin{quote}
    name[/name]*
\end{quote}

That is, a sequence of names separated by slashes. The semantics is:

\begin{enumerate}
  \item Look the first name in the namespace stack.

  \item If there are more names left, the last value found must be a namespace,
    then look the next name in that namespace. Iterate until the last name
    is consumed.

  \item Once the end of the sequence is reached, we will have a value. If
    the value is callable, then call it to get a new value.

  \item Finally, we should have a value that is either an string, a boolean
    or a sequence, depending on which statement ({\tt content}, {\tt repeat},
    etc.) the expression is being used with.
\end{enumerate}



