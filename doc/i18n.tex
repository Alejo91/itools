\chapter{Internationalization and Localization}
\label{Chapter: i18n}

The task tracker from the previous chapter provides a user interface in
only one language. The purpose of this chapter is to explain how to build
applications that provide a user interface in many languages. We will
illustrate this building up on the task tracker example.

See the file layout of the already multilingual task tracker:

\begin{code}
    Makefile
    TaskTracker.py
    TaskTracker_view.xml.en
    locale/
      locale.pot
      en.po
      es.po
\end{code}

There are two things to note. First the {\tt locale} directory: it is
a database which keeps the translations for the text messages of the user
interface. The translations are stored in {\em PO}\footnote{XXX} files,
one per language; in our example there is one for English ({\tt en.po})
and another for Spanish ({\tt es.po}). Each {\em PO} file keeps the source
messages, usually written in English, and their translations (because the
source language is English, the {\tt en.po} file will be usually empty).

The second thing to note is the {\tt Makefile}, it will help us to automatize
the localization and build processes. The Figure~\ref{Figure: l10n} shows
these two processes.

\begin{figure}
  \center
  \includegraphics[width=\textwidth]{l10n.eps}
  \caption{The localization process}
  \label{Figure: l10n}
\end{figure}


\section{Internationalization}

Internationalization:

\begin{quote}
  \em
  the operation by which a program, or a set
  of programs turned into a package, is made aware of and able to support
  multiple languages.
\end{quote}

This is to say, if you have a monolingual product like the task tracker from
the previous chapter, you will need to make some changes to the code, so it
becomes able to deal with multiple languages. This process is called
{\em internationalization}. Of course, you may also write international
software since the beginning.

The text messages to translate are stored in the XML templates and the Python
code, so these are the two things to internationalize.

\subsection{Python code}

To start, our task tracker must be {\em domain aware}:

\begin{code}
    from itools.gettext.domains import DomainAware

    class TaskTracker(Text, DomainAware):

        class_mimetypes = ['text/x-task-tracker']
        class_domain = 'task tracker'
\end{code}

We use here the word {\em domain} because it is standard in the
internationalization jargon. Here by a {\em domain} we understand a
database that keeps message translations for one or more languages.
A {\em domain aware} class is one that is implicitly associated to a
domain and has an API to access that domain.

Every application and library will have a unique domain name, this will
allow us to explicitly refer to a given domain to retrieve translations
from it. The domain name is specified with the class variable
{\tt class\_domain}.

By the way, we need to register the domain:

\begin{code}
    from itools import get_abspath
    from itools.gettext.domains import register_domain

    domain_path = get_abspath(globals(), '../locale')
    register_domain(TaskTracker.class_domain, domain_path)
\end{code}

The class {\tt DomainAware} provides the application programming interface
we will use within the Python code:

\begin{api}
  {\tt get\_languages()}\\
  - Returns a list with the language codes of our application. By default it
    is not implemented, so it must be overriden by subclasses.

  {\tt select\_language(languages=None)}\\
  - Chooses and returns a language from the given list of languages. If the
    languages are not given, the method {\tt get\_languages} will be called
    to get them. The default implementation uses the environment variable
    {\tt LANGUAGE}.

  {\tt gettext(message, language=None, domain=None)}\\
  - Returns the translation for the given message in the given language,
    from the given domain. If there is not a translation the input message
    is returned. If no language is given the method {\tt select\_language}
    will be called to choose one from the languages available in the
    domain. By default the domain used is the one specified in the class
    variable {\tt class\_domain}.
\end{api}

Now we just need to replace every text string in the source code by a
call to {\tt gettext}, e.g {\tt u'hello'} becomes {\tt self.gettext(u'hello')}.
In our example it would be:

\begin{code}
    def show_open_tasks(self):
        for id, task in enumerate(self.state.tasks):
            if task.state == 'open':
                print self.gettext(u'Task #%(id)d: %(title)s') \
                      % {'id': id, 'title': task.title}
        ...
\end{code}

Note that we have used named arguments for the formatted string instead
of positional arguments. This is because the position of the arguments
may be different in another language.

\subsection{Templates}


The technique we use with {\tt itools} requires to have one template per
language, being English the master language. Each template must have a
distinct name, we will achieve it by appending the language code to the
end of the file:

\begin{code}
    TaskTracker_view.xml.en
    TaskTracker_view.xml.es
\end{code}

Note that only the template in English belongs to the source, the others
will be automatically built with the help of {\tt itools}.

Now we are going to make some changes to the {\tt TaskTracker} class.
First we must override the method {\tt get\_languages}:

\begin{code}
    def get_languages(self):
        return ['en', 'es']
\end{code}

These are the languages of our task tracker, English and Spanish. Now we
must modify the {\tt view} method to choose the right template:

\begin{code}
    def view(self):
        # Load the STL template
        language = self.select_language()
        handler = get_handler('TaskTracker_view.xml.%s' % language)
        ...
\end{code}


\section{Localization}

Localization:

\begin{quote}
  \em
  the operation by which, in a set of programs already internationalized,
  one gives the program all needed information so that it can adapt itself
  to handle its input and output in a fashion which is correct for some
  native language and cultural habits.
\end{quote}

The source is ready, now starts the localization process, it consists of
two steps:

\begin{enumerate}
  \item Message extraction.
  \item Human translation.
\end{enumerate}


\subsection{Message extraction}

This step consists on the parsing of the source code, the extraction of
the translatable messages they contain, and the building of a {\em PO}
file which will be the input for the human translator.

This is done with the
{\tt GNU gettext}\footnote{http://www.gnu.org/software/gettext/} tools,
which are the standard in the Free Software world for software
internationalization and localization; and the script {\tt igettext.py}
provided by {\tt itools}.

But the process is automatized by the {\tt Makefile} so the only thing we
need to do is to type:

\begin{code}
    $ make po
\end{code}

This will parse the Python and XHTML source and update the PO files within
the {\tt locale} directory. See below an excerpt:

\begin{code}
    #: TaskTracker.py:117
    #, python-format
    msgid "Task #%(id)d: %(title)s"
    msgstr ""

    #: TaskTracker_view.xml.en:0
    msgid "Task Tracker"
    msgstr ""
\end{code}


\subsubsection{Marking messages}

The message extraction script will pick all text strings\footnote{Text
strings are most often known as unicode strings in Python.} from the Python
source, and all text nodes from the source templates. Then it will split
the messages into sentences, a process known as segmentation, it will
be these sentences which will feed the message catalog.

This means that no explicit markup is required to signal a text string
as translatable. This way we reduce the burden on the developer, who just
needs to remember to use Python unicode strings for text, i.e. to type:

\begin{code}
    u'Hello world.'
\end{code}

instead of:

\begin{code}
    'Hello world.'
\end{code}

For the templates, the only rule is to write them properly. In particular,
to use block elements as block elements, and inline elements as inline
elements.



\subsection{Human translation}

The human translator receives the PO file, and must return the same PO
file, but including the translations for every message. In our example
the output should be:

\begin{code}
    #: TaskTracker.py:117
    #, python-format
    msgid "Task #%(id)d: %(title)s"
    msgstr "Tarea #%(id)d: %(title)s"

    #: TaskTracker_view.xml.en:0
    msgid "Task Tracker"
    msgstr "Gestor de tareas"
\end{code}

To do this work the translator don't needs to understand the file format,
there are graphical tools available to do the job like:

\begin{itemize}
  \item KBabel, {\tt http://www.kde.org}
  \item poedit, {\tt http://poedit.sourceforge.net}
\end{itemize}



\section{Build}

To close the process, we must generate the translated templates
({\tt TaskTracker\_view.xml.es}) and the {\em MO} files ({\tt en.mo},
{\tt es.mo}) that will be used in runtime by the {\tt gettext} method.

To build the templates from the master template 
({\tt TaskTracker\_view.xml.en}) and from the translated PO file ({\tt es.po}),
is done with the script {\tt igettext.py}:

\begin{code}
    $ igettext.py --xhtml addressbook_view.xml.en es.po \
          > addressbook_view.xml.es
\end{code}

The MO file is a binary version of the PO file, and is built with the
{\tt msgfmt} tool.

But, again, the process is automatized by the {\tt Makefile}, so the only
thing we need to do is to type:

\begin{code}
    $ make bin
    igettext.py --output=TaskTracker_view.xml.es \
      --xhtml TaskTracker_view.xml.en locale/es.po
    msgfmt locale/en.po -o locale/en.mo
    msgfmt locale/es.po -o locale/es.mo
    touch bin
\end{code}

And {\em voilà}.



