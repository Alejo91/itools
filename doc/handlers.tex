\chapter{Resource Handlers}

Resources provide persistence to our data, but they lack any knowledge
about the structure and the meaning of the information they contain. For
example, the resource layer ignores that an XML document has a tree
structure, hence it does not provide an API to traverse it; nor it knows
how to get the messages and translations from a PO file.

This is the purpose of the {\em resource handlers}, to add semantics to
specific resources.


\section{Introduction}

Let's start with an example:

\begin{enumerate}
  \item First we load a resource as seen in the previous chapter:
\begin{code}
    >>> from itools.resources import get_resource
    >>> resource = get_resource('http://example.com')
\end{code}

  \item Now we build a handler for the resource:
\begin{code}
    >>> from itools.xml import HTML
    >>> handler = HTML.Document(resource)
    >>> print repr(handler)
    <itools.handlers.HTML.Document object at 0x40647b4c>
    >>> print handler.to_str()
    <HTML>
    <HEAD>
      <TITLE>Example Web Page</TITLE>
    </HEAD> 
    <body>  
    <p>You have reached this web page by typing
    ...
\end{code}

  \item Now we can start working with the handler:
\begin{code}
    >>> from itools.xml import XML
    >>> for node in handler.traverse():
    ...     if isinstance(node, XML.Element) and node.name == 'title':
    ...         print node.children
    Example Web Page
\end{code}
\end{enumerate}


\subsection{One resource, many handlers}

The relationship between resources to handlers is {\em 1} to {\em n}.
While you may have several different handlers associated to the same
resource (though this is rarely useful), a handler is only associated
to one resource.

The resource associated to a handler is accessible through the {\tt resource}
attribute:

\begin{code}
    >>> resource
    <itools.resources.http.File instance at 0x404aadec>
    >>> handler.resource
    <itools.resources.http.File instance at 0x404aadec>
    >>> resource is handler.resource
    True
\end{code}


\subsection{The handler skeleton}

As we have seen the handler constructor expects one parameter: the resource
it is meant to handle (and once the handler is built the resource is always
accessible with {\tt handler.resource}).

However, it is also possible to build a handler without passing it any
parameter; in this case a memory resource will be built on the fly, let's
see an example:

\begin{code}
    >>> from itools.xml import HTML
    >>> handler = HTML.Document()
    >>> handler
    <itools.handlers.HTML.Document object at 0x403ee12c>
    >>> handler.resource
    <itools.resources.memory.File instance at 0x40638e4c>
    >>> print handler
    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
      "http://www.w3.org/TR/html4/loose.dtd">
    <html>
      <head>
        <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
        <title></title>
      
      <body></body>
    </head></html>
\end{code}

The default content of the resource depends on the handler, and it is called
the {\em handler skeleton}. The constructor also accepts arbitrary keyword
parameters:

\begin{code}
    >>> handler = HTML.Document(title='Hello World')
    >>> print handler
    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
    <html>
      <head>
        <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"></meta>
        <title>Hello World</title>
      </head>
      <body></body>
    </html>
\end{code}

The keyword parameters are used to initialize the skeleton; in the example
above the {\tt title} parameter defines the HTML document title, which by
default is empty. The parameters accepted depend on the handler.


\section{Overview of the available handlers}

Out of the box {\tt itools} comes with several handlers for different
standard file formats. The Figure~\ref{Figure: handler tree} shows an
excerpt of the tree of the available handler classes, which express the
inheritance relationship between them.

\begin{figure}
  \center
  \includegraphics[height=\textwidth]{handlers.eps}
  \caption{The handler tree}
  \label{Figure: handler tree}
\end{figure}

Follows a short description of these handler classes, including the most
relevant part of the API.

\paragraph{File}

This is the default handler for files, to be used when there is nothing
better. The API is really basic:

\begin{api}
  {\tt to\_str()}\\
  - Returns the resource data as a byte string (this is similar to the
    method {\tt handler.resource.get\_data()}).
\end{api}

\paragraph{Text}

The default handler for text files, whose API is:

\begin{api}
  {\tt to\_unicode(encoding=None)}\\
  - Returns the resource data as an unicode string.

  {\tt to\_str(encoding='UTF-8')}\\
  - Returns the resource data as a byte string, using the given encoding
  (defaults to {\tt UTF-8}). Note that this will be different than the
  string returned by {\tt handler.resource.get\_data()} if the resource
  data is not encoded in {\tt UTF-8} in the source.
\end{api}

\paragraph{XML.Document}

This is the default handler for XML documents, which internally are
represented as a tree. The API includes the methods already described
for the {\tt Text} handler; specific methods of {\tt XML.Document} are:

\begin{api}
  {\tt \_\_cmp\_\_(other)}\\
  - Lets to compare two XML documents.

  {\tt get\_root\_element()}\\
  - Returns the root element of this XML document.

  {\tt traverse()}\\
  - This method allows to traverse the XML document, as it has a tree
    structure. It is a generator which returns a node at a time, starting
    by the document instance.

  {\tt traverse2()}\\
  - As {\tt traverse}, this method allows to traverse the XML document,
    though it is more powerful, and complex. It will be explained in the
    XML chapter.
\end{api}

\paragraph{XHTML.Document}

The handler for XHTML documents, it extends the API provided by
{\tt XML.Document} API with the methods:

\begin{api}
  {\tt get\_head()}\\
  - Returns the head element.

  {\tt get\_body()}\\
  - Returns the body element.

  {\tt to\_text()}\\
  - Strips all the XML markup and returns the text content of the XHTML
    document. This is useful, for example, to index the document.
\end{api}

\paragraph{PO}

The handler to manage PO files, the message catalog of the GNU gettext
utilities.

\begin{api}
  {\tt get\_msgids()}\\
  - Returns the list of message ids stored in the catalog.

  {\tt get\_messages()}\\
  - Returns the list of messages stored in the catalog, where each message
    is represented as an instance of the class {\tt PO.Message}.

  {\tt get\_msgstr(msgid)}\\
  - Returns the message string for the given message id.

  {\tt set\_message(msgid, msgstr=[u''], comments=[u''], references=\{\})}\\
  - Adds a message (from the given parameters) to the catalog.
\end{api}


\section{The handler factory}

So far we have built a handler instance through a handler class:

\begin{code}
    >>> handler = HTML.Document(resource)
    >>> handler
    <itools.xml.HTML.Document object at 0x405740cc>
\end{code}

This is the standard pattern to build instances. However, if the resource
is not an HTML document this procedure would fail. In other words, this
procedure is only useful if you already know the kind of resource you
are working with.

Another option is to let {\tt itools} to choose which handler class to use.
This can be done with the {\tt build\_handler} method, which provides the
factory pattern.

\begin{api}
  {\tt build\_handler(resource)}\\
  - A class method that identifies the given resource, chooses the available
  handler class that better matches it, and builds and returns a handler for
  it.
\end{api}

For example, from the {\tt examples} directory type:

\begin{code}
    >>> from itools.resources import get_resource
    >>> from itools.handlers.Handler import Handler
    >>> from itools import xml
    >>> 
    >>> here = get_resource('.')
    >>> for name in here.get_resource_names():
    ...     resource = here.get_resource(name)
    ...     handler = Handler.build_handler(resource)
    ...     print name, repr(handler)
    ... 
    chapter6 <itools.handlers.Folder.Folder object at 0x40538d4c>
    chapter7 <itools.handlers.Folder.Folder object at 0x4032c0cc>
    hello.txt <itools.handlers.Text.Text object at 0x40536f4c>
    hello.xhtml <itools.xml.XHTML.Document object at 0x4053b70c>
    hello.xml <itools.xml.XML.Document object at 0x40538d6c>
\end{code}

Note that {\tt build\_handler} is a class method. In the example above
we have called it through the most abstract handler class: {\tt Handler},
which is the root of the inheritance tree. But it is also possible to call
it with another handler class:

\begin{code}
    >>> from itools.xml import XML
    >>> 
    >>> resource = here.get_resource('hello.xhtml')
    >>> XML.Document.build_handler(resource)
    <itools.xml.XHTML.Document object at 0x405c6ecc>
\end{code}

There is an important difference between calling {\tt build\_handler} from
one or another class: the set of possible handler classes to use is
restricted to all the sub-classes of the choosen handler class. For example,
if we pass a plain text file to {\tt XML.Document.build\_handler}, it will
fail:

\begin{code}
    >>> resource = here.get_resource('hello.txt')
    >>> XML.Document.build_handler(resource)
    Traceback (most recent call last):
      [...]
    xml.parsers.expat.ExpatError: syntax error: line 1, column 0
\end{code}


\subsection{The {\tt get\_handler} shorthand}

There is a short way to load a handler (instead of loading first the resource
and then building the handler explicitly), the function {\tt get\_handler}:

\begin{api}
  {\tt get\_handler(uri)}\\
  - Loads the resource at the given uri, tries to guess its mimetype by
  different meanings (name extension, etc.), searches for a suitable
  handler class in the registry, builds and returns the handler for
  the resource.
\end{api}

Compare the explicit way seen before:

\begin{code}
    >>> from itools.resources import get_resource
    >>> from itools.handlers.Handler import Handler
    >>>
    >>> resource = get_resource('http://example.com')
    >>> handler = Handler.build_handler(resource)
\end{code}

With the shorthand:

\begin{code}
    >>> from itools.handlers import get_handler
    >>>
    >>> handler = get_handler('http://example.com')
\end{code}


\section{Folders}

A handler that deserves its particular section is the default handler for
folders, whose core API is:

\begin{api}
  {\tt get\_handler(path)}\\
  - Returns a handler for the resource at the given path. It will use the
    available handler class that better matches the resource mimetype.

  {\tt get\_handler\_names(path='.')}\\
  - Returns a list with the names of all the handlers in the given path.

  {\tt get\_handlers(path='.')}\\
  - Returns the handlers in the given path (it is a generator).

  {\tt has\_handler(path)}\\
  - Returns {\tt True} if there is a handler in the given path, {\tt False}
    otherwise.

  {\tt set\_handler(path, handler)}\\
  - Adds the given handler to the given path. Actually what is added is
    the resource associated to the handler.

  {\tt del\_handler(path)}\\
  - Removes the handler at the given path (i.e. the associated resource).
\end{api}

An example will show it better.

\begin{enumerate}
  \item First we build a handler for the temporary directory:

\begin{code}
    >>> from itools.handlers import get_handler
    >>>
    >>> tmp = get_handler('/tmp')
    >>> tmp
    <itools.handlers.Folder.Folder object at 0x40652dec>
    >>> tmp.resource
    <itools.resources.file.Folder instance at 0x406acacc>
\end{code}

  \item Second, we create a new HTML handler:

\begin{code}
    >>> from itools.xml import HTML
    >>> hello = HTML.Document(title='Hello World')
    >>> hello.resource
    <itools.resources.memory.File instance at 0x405e49cc>
\end{code}

    Note that the associated resource is built on the fly and lives in memory.

  \item Third, we set the HTML handler to the temporary folder:

\begin{code}
    >>> tmp.set_handler('hello.html', hello)
\end{code}

    What this actually does is to add the file {\tt hello.resource} (which
    lives in memory) to the folder {\tt tmp.resource} (which is on the
    file system); this is to say, it creates a new file in the file system
    at {\tt /tmp/hello.html}.

  \item Finally, we get the handler we just added:

\begin{code}
    >>> hello = tmp.get_handler('hello.html')
    >>> hello.resource
    <itools.resources.file.File instance at 0x40638c6c>
\end{code}

    Note that the handler {\tt hello} we have built in these last lines
    manages a resource that lives in the file system.

\end{enumerate}



\subsection{The handler tree}

Folders allow to classify files, hence giving a tree structure to our data.
Every handler has two attributes, {\tt parent} and {\tt name}, they tell us
where the handler is in the handler tree:

\begin{code}
    >>> hello.parent
    <itools.handlers.Folder.Folder object at 0x403ebb2c>
    >>> hello.name  
    'hello.html'
    >>> hello.parent is tmp
    True
    >>> print tmp.parent
    None
    >>> print tmp.name

    >>> 
\end{code}

Based on these two attributes handlers provide the following API:

\begin{api}
  {\tt get\_abspath()}\\
  - Returns the absolute path from the tree root to the {\tt self} handler.

  {\tt get\_root()}\\
  - Returns the handler for the root of the tree.

  {\tt get\_pathtoroot()}\\
  - Returns a relative path from {\tt self} to the tree root (e.g.
    {\tt ../../..}).

  {\tt get\_pathto(handler)}\\
  - Returns a relative path from {\tt self} to the given handler (which is
    supposed to be in the same tree), for example: {\tt ../../zoo/lion}.

  {\tt traverse()}\\
  - This method allows to traverse the handler tree below this folder. It
    is a generator which returns a handler at a time, starting by this
    folder.

  {\tt acquire(name)}\\
  - If the current handler is a folder and contains a resource with the given
    name, then return a handler for it; otherwise look at the parent folder,
    and recursively to the root tree. This method actually shows how to
    implement {\em acquisition}.
\end{api}
