
\chapter{Uniform Resource Identifiers}

In the wild Internet, the first challenge we encounter is how to identify
and locate the numerous resources that populate it. Well, that's what
{\bf U}niform {\bf R}esource {\bf I}dentifiers (or just URIs) are for.

The Python Standard Library (batteries included!!) provides a module named
{\tt urlparse} which is able to split a generic URI into its main parts,
to rebuild it, and to resolve relative references.

But there are more things we would like to do with a URI. For example we
could go further in the parsing process and split the path into its segments,
then split each segment into the name and the parameters if any; we could
get the user information, host address and port number from the authority;
we could normalize URIs; we could implement other operations beyond just
resolving relative references, etc.

This is the purpose of {\tt itools.uri}, to provide a complete API to parse
and work with URIs, following the standard as described by {\bf RFC2396}.

The reference factory is {\tt get\_reference}:

\begin{api}
    {\tt get\_reference(reference)}\\
    - Parses the given string and returns a reference object.
\end{api}

Let's go right to the code:

\begin{code}
    >>> from itools import uri
    >>> r1 = uri.get_reference('http://www.w3.org/TR/REC-xml/#sec-intro')
    >>> r2 = uri.get_reference('mailto:jdavid@itaapy.com')
    >>> r3 = uri.get_reference('http://www.ietf.org/rfc/rfc2616.txt')
    >>> r4 = uri.get_reference('http://sf.net/cvs/?group_id=5470')
    >>> r5 = uri.get_reference('news:comp.infosystems.www.servers.unix')
\end{code}


\section{Syntax}

Before going further, we will give an overview of the URI syntax, something
required to understand the rest of the section.

A URI is divided in two parts. The first one is the scheme: {\tt http},
{\tt ftp}, {\tt mailto}, etc.. The syntax and semantics of the second
part depends on the scheme:

\begin{verbatim}
    uri = <scheme>:<scheme-specific-part>
\end{verbatim}

However, many schemes share a similar syntax for the second part, these
URIs are known as {\em generic URIs}.

\subsection{Generic URIs}

The syntax of a generic URI reference is:

\begin{verbatim}
    <scheme>://<authority><absolute path>?<query>#<fragment>
\end{verbatim}

Generic URIs are modeled by {\tt uri.Reference}. Following the code at the
beginning, we are going to inspect the {\tt r1} object:

\begin{code}
    >>> r1
    <itools.uri.Reference object at 0x403ebc4c>
    >>> print r1
    http://www.w3.org/TR/REC-xml/#sec-intro
    >>> print r1.scheme
    http
    >>> print r1.authority
    www.w3.org
    >>> print r1.path     
    /TR/REC-xml/
    >>> print r1.query

    >>> print r1.fragment
    sec-intro
\end{code}

Note that there is an attribute for every component: the scheme, the
authority, the path, the query and the fragment. Now we are going to
quickly describe each of these components:

\begin{description}
  \item [Scheme] Defines the method or protocol to access the resource.

  \item [Authority] Defines the server address that hosts the resource.
    Its syntax is:

\begin{verbatim}
    authority = [<userinfo>@]<hostport>
\end{verbatim}

  \item [Absolute path] The path identifies the resource within the scope
    of the scheme and authority.

    It consists of a sequence of segments. A segment has two parts, the
    name and the parameters, though the parameters are optional. The syntax is:

\begin{verbatim}
    absolute path = /<relative path>
    relative path = <segment>[/<relative path>]
    segment = <name>[;<parameters>]
\end{verbatim}

  \item [Query] The query is information to be interpreted by the resource.
    It does not have a pre-defined syntax.

  \item [Fragment] The fragment is a reference within the resource.

    Actually, the fragment does not belong to the URI, as it does not
    identifies the resource, however we include it here because it does
    appears in URI references, what is what we work with.

    As the query, the fragment does not have a pre-defined syntax.
\end{description}


\subsection{Non Generic URIs}

Other schemes do not follow the generic syntax. As an example, let's inspect
the {\tt r2} object seen before:

\begin{code}
    >>> r2 = uri.get_reference('mailto:jdavid@itaapy.com')
    >>> print r2
    mailto:jdavi@itaapy.com
    >>> r2
    <itools.uri.Mailto object at 0x403f45ec>
    >>> print r2.scheme
    mailto
    >>> print r2.username
    jdavid
    >>> print r2.host    
    itaapy.com
\end{code}

As you see the {\tt r2} is not an instance of {\tt uri.Reference}, but an
instance of {\tt uri.Mailto}.


\section{Relative references}

So far the examples we have seen show absolute URIs, but there are relative
URI references too. A relative reference is one that lacks, at least, the
scheme. There are three types of of relative references: network paths,
absolute paths, and relative paths:

\begin{description}
  \item [Network paths] Network paths only lack the scheme, they start by a
    double slash and the authority, followed by the absolute path. They are
    rarely used.

\begin{verbatim}
    //www.ietf.org/rfc/rfc2396.txt
\end{verbatim}

  \item [Absolute paths] The absolute paths lack both the scheme and the
     authority. They start by an slash.

\begin{verbatim}
    /rfc/rfc2396.txt
\end{verbatim}

  \item [Relative paths] Relative paths lack the first slash of absolute
    paths. They can start by the special segment "{\tt .}", or by a one or
    more "{\tt ..}". Examples are:

\begin{verbatim}
    rfc/rfc2396.txt
    ./rfc/rfc2396.txt
    ../rfc2616.txt
\end{verbatim}

\end{description}


\subsection{Resolving references}

Often we want to resolve a relative reference, that is to say, to calculate
a new reference from an absolute one (called the {\em base} reference) and
from a relative one. This is achieved with the {\tt resolve} method:

\begin{code}
    >>> base = uri.get_reference(http://www.ietf.org/rfc/rfc2615.txt)
    >>> print base.resolve('//www.ietf.org/rfc/rfc2396.txt')
    http://www.ietf.org/rfc/rfc2396.txt
    >>> print base.resolve('/rfc/rfc2396.txt')
    http://www.ietf.org/rfc/rfc2396.txt
    >>> print base.resolve('rfc2396.txt')
    http://www.ietf.org/rfc/rfc2396.txt
\end{code}


\section{Paths}

One component that deserves special attention is the path. The path of a
generic URI is an instance of the {\tt uri.Path} class:

\begin{code}
    >>> ref = uri.get_reference('http://www.ietf.org/rfc/rfc2616.txt')
    >>> ref.path
    <itools.uri.Path at 0x403f50a4>
    >>> print ref.path
    /rfc/rfc2616.txt
\end{code}

Paths are iterable:

\begin{code}
    >>> for segment in ref.path:
    ...     print segment
    ... 
    rfc
    rfc2616.txt
\end{code}

Each component of the path is called a segment. Segments are instances of
the class {\tt uri.Segment}. Each segment has two components, the name and
the parameter. The code below illustrates this:

\begin{code}
    >>> path = uri.Path('/itaapy;lang=es/team')
    >>> for segment in path:
    ...     print repr(segment)
    ...     print '  name="%s", param="%s"' % (segment.name, segment.param)
    ... 
    <itools.uri.Segment object at 0x403f562c>
      name="itaapy", param="lang=es"
    <itools.uri.Segment object at 0x403f568c>
      name="team", param="None"
\end{code}

The {\tt uri.Path} class also provides an API to manipulate paths:

\begin{api}
  {\tt is\_absolute()}\\
  - Returns {\tt True} if the path is absolute (i.e. if it starts by an
  slash), {\tt False} otherwise.

  {\tt is\_relative()}\\
  - Returns {\tt True} if the path is relative (i.e. if it does not start
    by an slash), {\tt False} otherwise.

  {\tt get\_prefix(path)}\\
  - Returns the path that is common to {\tt self} and to the given path.

  {\tt resolve(path)}\\
  - Returns a new path from a base path ({\tt self}) and the given path.

  {\tt get\_pathto(path)}\\
  - Returns the path needed to go from {\tt self} to the given path (this
    complements the {\tt resolve} method).

  {\tt get\_pathtoroot()}\\
  - Returns a relative path to the root (something like {\tt ../../..}).
\end{api}

