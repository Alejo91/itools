\chapter{Writing handler classes}

In previous chapters we have seen some of the handlers {\tt itools} provides
out of the box, and how they help us to work with resources (e.g. XML
documents).


This chapter explains how to build your own handler classes, which will let
you to add support for file formats either standard or defined by yourself.
The explanation will be driven by an example.

Following up the previous chapter, we will extend our addressbook, which
will become a handler class. This means that the list of addressess (each
one with its last name, first name and telephone number) will be stored in
a resource, hence giving persistence to our addressbook.

\section{Step by step}

The process to write a handler class can be splitted in several steps, these
are:

\begin{enumerate}
  \item First the file format must be choosen or designed. If there is an
    standard file format that matches our requirements it could be wise to
    use it. Other option is to design our own.

    For example, if, in the context of a miltilingual application, we want
    to have a catalog that keeps sentences in one language and its
    translations to another language, then there are two obvious options,
    the PO file format from GNU gettext and the TMX standard ({\bf T}ranslation
    {\bf M}emory e{\bf X}change\footnote{http://www.lisa.org/tmx}).

    In other situations we may want to design our own format, this is the
    case we will illustrate in this chapter with the new version of
    the addressbook.

  \item The second step is to choose the handler class to use as base class.

    For instance, if we're going to write a handler for TMX the base handler
    class should be {\tt XML.Document}. If we want to write a handler for
    {\bf C}omma {\bf S}eparated {\bf V}alue files, then our class should
    inherit from {\tt Text}.

  \item Usually we will implement the method {\tt \_load()}, which is the
    responsible to parse the resource data and to build the data structure
    we want in memory.

  \item Next is to write the method {\tt to\_str}, which serializes the
    handler and lets to save it into the resource.

  \item It is likely we will also write the method {\tt get\_skeleton()}
    which must return the default content of a resource.

  \item Finally we will develop the specific API that will enable us to
    work with our handler.
\end{enumerate}

\section{Example: Addressbook}

An adressbook could be stored in a resource using different file formats,
we are going to use an XML based one, below is an example (which can be
found in {\tt examples/chapter7/addressbook.xml}):

\begin{code}
    <?xml version="1.0" encoding="UTF-8"?>
    <addressbook>
      <address>
        <lastname>Jordan</lastname>
        <firstname>Robert</firstname>
        <telephone>0606060606</telephone>
      </address>
      <address>
        <lastname>Buendia</lastname>
        <firstname>Aureliano</firstname>
        <telephone>0612345678</telephone>
      </address>
    </addressbook>
\end{code}

Being an XML document, it is clear our handler class should inherit from
{\tt XML.Document}:

\begin{code}
    from itools.xml import XML

    class Addressbook(XML.Document):
        ...
\end{code}


\subsection{Load and Save}

If you remember the previous chapter, the addressbook was stored on memory
as a list of dictionaries. We are going to keep the same data structure.

Our goal is to be able to:

\begin{enumerate}
  \item Load the resource data, which we will use to feed the handler data
    structure with it.

  \item Modify the handler (add, edit or remove addresses).

  \item Save the changes on the resource.
\end{enumerate}

Our focus now are the {\em load} and {\em save} operations.


\subsubsection{Load}

The method responsible to load the resource, and which we must implement,
is {\tt \_load}:

\begin{code}
    class Addressbook(XML.Document):
        def _load(self):
            # Load the XML tree
            XML.Document._load(self)
            # Initialize data structure
            self.addresses = []
            # Load addressbook
            addressbook_element = self.get_root_element()
            for address_element in addressbook_element.get_elements():
                # Initialize address record with default values
                address = {'last_name': '',
                           'first_name': '',
                           'telephone': ''}
                # Load values from the XML resource
                for element in address_element.get_elements():
                    if element.name == 'lastname':
                        address['last_name'] = unicode(element.children)
                    elif element.name == 'firstname':
                        address['first_name'] = unicode(element.children)
                    elif element.name == 'telephone':
                        address['telephone'] = unicode(element.children)
                # Add to the list of addresses
                self.addresses.append(address)
            # Clean the unneeded XML tree
            del self.children
\end{code}

Note that the {\tt \_\_init\_\_} method has been removed, this method is
provided by the {\tt itools.handlers.File.File}, and should never be
implemented in our custom handler classes.

Now let's test our handler class:

\begin{code}
    >>> from pprint import pprint
    >>> from itools.resources import get_resource
    >>> from addressbook import Addressbook
    >>>
    >>> r = get_resource('addressbook.xml')
    >>> addressbook = Addressbook(r)
    >>> addressbook
    <addressbook.Addressbook object at 0x4058004c>
    >>> 
    >>> pprint(addressbook.addresses)
    [{'first_name': u'Robert',
      'last_name': u'Jordan',
      'telephone': u'0606060606'},
     {'first_name': u'Aureliano',
      'last_name': u'Buendia',
      'telephone': u'0612345678'}]
\end{code}

What we have done is to load the data contained in a file resource on an
easy to use data structure on memory, this process is also known as
de-serialization (to transform a byte string to a data structure).

\subsubsection{Save}

Now we are going to do the opposite, to transform the data structure to
a byte string (the process known as serialization). This way we will be
able to save the changes we do to our the handler instance.

The method we are going to implement is {\tt to\_str}, which must return
a byte string representing the data contained by the handler:

\begin{code}
    class Addressbook(XML.Document):
        def _load(self):
            ...


        def to_str(self, encoding='UTF-8'):
            # XML declaration
            data = u'<?xml version="1.0" encoding="%s"?>\n' % encoding
            # Open root element
            data += u'<addressbook>\n'
            # Addresses
            for address in self.addresses:
                pattern = u'  <address>\n' \
                          u'    <lastname>%(last_name)s</lastname>\n' \
                          u'    <firstname>%(first_name)s</firstname>\n' \
                          u'    <telephone>%(telephone)s</telephone>\n' \
                          u'  </address>\n'
                data += pattern % address
            # Close root element
            data += u'</addressbook>'
            # Return as a byte string
            return data.encode(encoding)
\end{code}

To test it type the code below:

\begin{code}
    >>> from itools.resources import get_resource
    >>> from addressbook import Addressbook
    >>>
    >>> r = get_resource('addressbook.xml')
    >>> addressbook = Addressbook(r)
    >>>
    >>> print addressbook
    <?xml version="1.0" encoding="UTF-8"?>
    <addressbook>
      <address>
        <lastname>Jordan</lastname>
        <firstname>Robert</firstname>
        <telephone>0606060606</telephone>
      </address>
      <address>
        <lastname>Buendia</lastname>
        <firstname>Aureliano</firstname>
        <telephone>0612345678</telephone>
      </address>
    </addressbook>
\end{code}

As you see the output is similar to the original resource, because we did not
modify the handler. Now we are going to add a new entry:

\begin{code}
    >>> addressbook.add_address('Bonaparte', 'Napoleon', '')
    >>> print addressbook
    <?xml version="1.0" encoding="UTF-8"?>
    <addressbook>
      <address>
        <lastname>Jordan</lastname>
        <firstname>Robert</firstname>
        <telephone>0606060606</telephone>
      </address>
      <address>
        <lastname>Buendia</lastname>
        <firstname>Aureliano</firstname>
        <telephone>0612345678</telephone>
     </address>
     <address>
       <lastname>Bonaparte</lastname>
       <firstname>Napoleon</firstname>
       <telephone></telephone>
     </address>
   </addressbook>
\end{code}

Now we have modified the handler, but look at the resource
{\tt examples/chapter7/addressbook.xml}, it still keeps the origianl two
entries. What we have now is that the handler and the resource it manages
are out of sync, the resource has not been updated with the changes made
to the handler. To update the resource the method {\tt save} must be used:

\begin{code}
    >>> addressbook.save()
\end{code}

If now you look at the resource you will see the new address.


\subsubsection{Load and Save}

The code above has showed how a resource may be outdated as it does not
contains the changes made to the handler, and how to sync it with the
method {\tt save}.

But the opposite may happen too, if you build a handler for a resource,
then you go and modify the resource with another application (e.g. {\em vi}
or {\em emacs}), then your handler will be outdated as it won't contain the
changes made to the resource. As maybe you have already guessed, the method
to update the handler is {\tt load}.

In summary the API is:

\begin{api}
  {\tt load()}\\
  - Loads the resource data into the handler.

  {\tt save()}\\
  - Saves the handler into the resource.
\end{api}


\subsubsection{}