\chapter{eXtensible Markup Language}

The purpose of this chapter is to explain the XML services provided by
{\tt itools}, which can be found in the sub-package {\tt itools.xml}.

\section{XML.Document}

The XML facilities provided by {\tt itools} are built upon the resource-handler
architecture. The basic handler class that enables us to manipulate XML files
is {\tt XML.Document}, now we are going to play a little bit with it:

\begin{code}
    >>> from itools.handlers import get_handler
    >>> import itools.xml
    >>>
    >>> doc = get_handler('examples/hello.xml')
    >>> doc
    <itools.xml.XML.Document object at 0x4064466c>
    >>> print doc.xml_version
    1.0
    >>> print doc.standalone 
    -1
    >>> print doc.document_type
    None
    >>> print doc.root_element
    <itools.xml.XML.Element object at 0xb7a3272c>
\end{code}

The code above shows the four attributes that keep the document's state:

\begin{api}
    {\tt xml\_version}\\
    - The XML version of the document, usually it is {\tt 1.0}.

    {\tt standalone}\\
    - Possible values are: {\tt 1} if the document was declared standalone,
      {\tt 0} if it was declared not to be standalone, or {\tt -1} if the
      standalone clause was omitted.

    {\tt document\_type}\\
    - If the document lacks a document type declaration this attribute will
      be {\tt None}. If the document type was specified this attribute will
      be a tuple with four values: the name, the system id, the public id
      and a boolean that tells wether the document contains an internal
      declaration subset.

    {\tt root\_element}\\
    - An instance of the {\tt XML.Element} class, the root of the DOM-like
      tree that represents the XML data, and that we will study later with
      more detail.
\end{api}


The API for the documents is rather simple:

\begin{api}
    {\tt get\_root\_element()}\\
    - Returns the root element.

    {\tt traverse()}\\
    - A generator that traverses the XML tree in pre-order, and returns
      each time a node. It is a shorthand for {\tt root\_element.traverse()}.

    {\tt traverse2()}\\
    - A more powerful version of {\tt traverse}. It is a shorthand for
      {\tt root\_element.traverse2()}.
\end{api}


\subsection{Inspecting the tree}

Coming back to the example, the {\tt examples/hello.xml} file's content is:

\begin{code}
    <?xml version="1.0" encoding="UTF-8"?>
    <html>
      <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Hello world</title>
        <!-- Changed by: , 02-Jun-2004 -->
      </head>
      <body>
      </body>
    </html>
\end{code}

The method {\tt traverse} lets us to easily inspect the tree nodes:

\begin{code}
    >>> for node in doc.traverse():
    ...     print repr(node)
    ... 
    <itools.xml.XML.Element object at 0xb7a3316c>
    u'\n  '
    <itools.xml.XML.Element object at 0xb7a331ac>
    u'\n    '
    <itools.xml.XML.Element object at 0xb7a332ac>
    u'\n    '
    <itools.xml.XML.Element object at 0xb7a331ec>
    u'Hello world'
    u'\n    '
    <itools.xml.XML.Comment object at 0xb7a335cc>
    u'\n  '
    u'\n  '
    <itools.xml.XML.Element object at 0xb798574c>
    u'\n  '
    u'\n'
\end{code}

Here we see the three kind of nodes currently supported: elements, comments
and text nodes.

\subsection{Elements}

Of the three kinds of nodes, elements are the most most important and complex.
Element nodes give the tree structure, as they are the only ones that may have
children. Following the example, lets look inside an element:

\begin{code}
    >>> root_element = doc.root_element
    >>> root_element
    <itools.xml.XML.Element object at 0xb7a3272c>
\end{code}



Lets to stop and look at the API of the most important node type,
{\tt XML.Element}:

\begin{api}
    {\tt parent}\\
    - It is the element's parent.

    {\tt attributes}\\
    - The element's attributes, it is a mapping from attribute names to
    {\tt XML.Attribute} objects.

    {\tt get\_elements(name=None)}\\
    - Returns a list with all the element nodes whose name is the given
    name; if the parameter {\tt name} is not given, then return all the
    element nodes.

    {\tt traverse()}\\
    - As with {\tt XML.Document}, this method is a generator that traverses
    the element children in pre-order, and returns each time a node.

    {\tt copy()}\\
    - Returns a copy of the element, including all its children; but with
    the attribute {\tt parent} set to {\tt None}.

    {\tt append\_child(node)}\\
    - Appends the given node to the element children, the current element will
    be the node's parent.
\end{api}


\section{Namespaces}

One very important concept of XML are the {\em namespaces}.

An XML document may contain many different elements and attributes, if there
is not any XML declaration these elements and attributes will be instances
of the {\tt XML.Element} and {\tt XML.Attribute} classes, with the standard
API and none specific semantics.

But if there are namespace declarations, {\tt itools.xml} will be able to
build specific objects that add some special semantics. To see it we are
going to load the file {\tt examples/hello.xhtml}, whose content is:

\begin{code}
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
           "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml">
      <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Hello world</title>
        <!-- Changed by: , 02-Jun-2004 -->
      </head>
      <body>
      </body>
    </html>
\end{code}

The only two differences between this file and the example we saw at the
beginning ({\tt examples/hello.xml}) are the {\em document type} declaration
and, what interests us now, the XML namespace declaration:

\begin{code}
    xmlns="http://www.w3.org/1999/xhtml"
\end{code}

What this sentence says is that all the elements and attributes within the
document belong to the XHTML namespace. This information lets the {\tt itools}
XML parser to build a more ``intelligent'' tree:

\begin{code}
    >>> resource = get_resource('examples/hello.xhtml')
    >>> doc = XML.Document(resource)
    >>> 
    >>> doc
    <itools.xml.XML.Document object at 0x405ea38c>
    >>> 
    >>> for node in doc.traverse():
    ...     print repr(node)
    ... 
    <itools.xml.XHTML.Element object at 0xb7a3316c>
    u'\n  '
    <itools.xml.XHTML.Element object at 0xb7a331ac>
    u'\n    '
    <itools.xml.XHTML.Element object at 0xb7a332ac>
    u'\n    '
    <itools.xml.XHTML.Element object at 0xb7a33f2c>
    u'Hello world'
    u'\n    '
    <itools.xml.XML.Comment object at 0xb798554c>
    u'\n  '
    u'\n  '
    <itools.xml.XHTML.Element object at 0xb79855ac>
    u'\n  '
    u'\n'
\end{code}

Now, the element nodes are not any more instances of {\tt XML.Element}, but
instances of {\tt XHTML.Element}, which extends the generic API with the
methods:

\begin{api}
    {\tt is\_inline()}\\
    - Returns {\tt True} if the element is an inline element, {\tt False}
    otherwise.

    {\tt is\_block()}\\
    - Returns {\tt True} if the element is a block element, {\tt False}
    otherwise.
\end{api}

Ok, not too much\footnote{These two methods, {\tt is\_inline} and
{\tt is\_block}, are actually really useful. They are used by the message
extraction algorithm, a fundamental brick of the internationalization and
localization services provided by {\tt itools}.}, but enough to give an
idea of the power of {\tt itools.xml}. In the next chapter we will see a
much more compelling example of what can be done with {\tt itools.xml},
the {\bf S}imple {\bf T}emplate {\bf L}anguage.


