\chapter{eXtensible Markup Language}

The purpose of this chapter is to explain the XML services provided by
{\tt itools}, which can be found in the sub-package {\tt itools.xml}.


\section{The parser}

The first layer is the event driven parser implemented by
{\tt itools.xml.parser}, which is a wrapper around the
{\tt expat}\footnote{http://expat.sourceforge.net/} parser.

With {\tt expat} you need a function for every event you want to manage,
so for example, if you want to deal just with elements, comments and text
nodes, you will need four functions (the start element, end element, comment
and character data handlers), plus the main function that sets up the
parser. State is typically shared across event handlers through instance
variables. The {\tt expat} approach makes it relatively hard to follow the
program flow.

With {\tt itools.xml.parser} all the code is within a single function, and
state is stored in local variables. Let's see a dummy example:

\begin{code}
    from itools.xml import parser

    for event, value, line_number in parser.parse(data):
        if event == parser.START_ELEMENT:
            namespace, prefix, local_name = value
            print 'START ELEMENT:', local_name
        elif event == parser.END_ELEMENT:
            namespace, prefix, local_name = value
            print 'END ELEMENT:', local_name
        elif event == parser.TEXT:
            print 'TEXT', value
\end{code}

The example above just prints a message to standard output each time the
start of an element, the end of an element or a text node is found.

The parser returns a list of events, where every event is a tuple of three
valuese: the event type, the value (which depends on the event type) and
the line number. The types of events implemented are:

\begin{quote}
  \begin{tabular}{ll}
    Event & Value\\\hline
    {\tt XML\_DECLARATION} & (xml version, encoding, standalone)\\
    {\tt DOCUMENT\_TYPE} & (name, system id, public id, has internal subset)\\
    {\tt START\_ELEMENT} & (namespace uri, prefix, local name)\\
    {\tt END\_ELEMENT} & (namespace uri, prefix, local name)\\
    {\tt ATTRIBUTE} & (namespace uri, prefix, local name, value)\\
    {\tt COMMENT} & value\\
    {\tt TEXT} & value\\
  \end{tabular}
\end{quote}

As you can appreciate only a subset of the XML standard is supported, though
it is all what most users need.

Another impotant thing to note is that all values returned are normal
strings, not unicode strings. It is not the job of the low level parser
to deserialize the values.


\section{Namespaces}

From the table above you can see {\tt itools.xml} provides support for XML
namespaces. The event values for elements and attributes are tuples, where
the first two components are the {\em namespace uri} and the {\em prefix}.
If an element or attribute is not attached to a namespace, the {\em uri}
and the {\em prefix} will be {\tt None}.

The module {\tt itools.xml.namespaces} provides a registry for namespace
handlers, and an abstract class which defines the programming interface
and provides a default behaviour for subclasses. The table below defines
this programming interface:

\begin{api}
    {\tt class\_uri}\\
    - The uri that uniquely identifies this namespace.

    {\tt class\_prefix}\\
    - The recommended prefix for the namespace. For example ``{\tt dc}''
      for Dublin Core. By default it is {\tt None}.

    {\tt get\_element\_schema(name)}\\
    - Returns the schema for the given element name.

    {\tt get\_attribute\_schema(name)}\\
    - Returns the schema for the given attribute name.
\end{api}

The schema is a dictionary whose keys and values are somewhat arbitrary,
they will depend on what you need. Though, it usually includes the type
of the attribute or element, which is used to deserialize and serialize
the values. For example, consider a link within an XHTML document, like:

\begin{code}
    <a href="http://www.example.com" title="Example" />
\end{code}

The {\tt href} attribute should be loaded as a URI reference, and {\tt title}
should be a unicode string. The excerpt below will do the job:

\begin{code}
    from itools.xml import parser, namespaces
    from itools import xhtml

    for event, value, line_number in parser.parse(data):
        if event == parser.ATTRIBUTE:
            namespace_uri, prefix, local_name, value = value
            namespace = namespaces.get_namespace(namespace_uri)
            schema = namespace.get_attribute_schema(local_name)
            value = schema['type'].decode(value)
            print local_name, schema['type']
            print repr(value)
            print
\end{code}

The output when running this code is:

\begin{code}
    href <class 'itools.handlers.IO.URI'>
    <itools.uri.generic.Reference object at 0xb7a8c8ac>

    title <class 'itools.handlers.IO.Unicode'>
    u'Example'
\end{code}

For examples about how to define your own namespace handlers see the Dublin
Core ({\tt itools.xml.DublinCore}) and XHTML ({\tt itools.xhtml.XHTML})
implementations.


\section{Documents}

If {\tt itools.xml.parser} provides an event driven parser, whose function
is similar to SAX\footnote{http://XXX}, we do have too an equivalent for
DOM\footnote{http://XXX}. And of course it takes the form of a resource
handler.

The handler class {\tt itools.xml.XML.Document} loads the document into memory
as a tree of nodes, with some global attributes. Let's inspect an example:

\begin{code}
    >>> from itools.handlers import get_handler
    >>> import itools.xml
    >>>
    >>> doc = get_handler('examples/chapter8/hello.xml')
    >>> doc
    <itools.xml.XML.Document object at 0x4064466c>
    >>> print doc.xml_version
    1.0
    >>> print doc.standalone 
    -1
    >>> print doc.document_type
    None
    >>> print doc.root_element
    <itools.xml.XML.Element object at 0xb7a3272c>
\end{code}

The code above shows the four attributes that keep the document's state:

\begin{api}
    {\tt xml\_version}\\
    - The XML version of the document, usually it is {\tt 1.0}.

    {\tt standalone}\\
    - Possible values are: {\tt 1} if the document was declared standalone,
      {\tt 0} if it was declared not to be standalone, or {\tt -1} if the
      standalone clause was omitted.

    {\tt document\_type}\\
    - If the document lacks a document type declaration this attribute will
      be {\tt None}. If the document type was specified this attribute will
      be a tuple with four values: the name, the system id, the public id
      and a boolean that tells wether the document contains an internal
      declaration subset.

    {\tt root\_element}\\
    - An instance of the {\tt XML.Element} class, the root of the DOM-like
      tree that represents the XML data, and that we will study later with
      more detail.
\end{api}


The API for the documents is rather simple:

\begin{api}
    {\tt get\_root\_element()}\\
    - Returns the root element.

    {\tt traverse()}\\
    - A generator that traverses the XML tree in pre-order, and returns
      each time a node. It is a shorthand for {\tt root\_element.traverse()}.

    {\tt traverse2()}\\
    - A more powerful version of {\tt traverse}. It is a shorthand for
      {\tt root\_element.traverse2()}.
\end{api}


\subsection{Inspecting the tree}

Coming back to the example, the {\tt examples/hello.xml} file's content is:

\begin{code}
    <?xml version="1.0" encoding="UTF-8"?>
    <html>
      <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Hello world</title>
        <!-- Changed by: , 02-Jun-2004 -->
      </head>
      <body>
      </body>
    </html>
\end{code}

The method {\tt traverse} lets us to easily inspect the tree nodes:

\begin{code}
    >>> for node in doc.traverse():
    ...     print repr(node)
    ... 
    <itools.xml.XML.Element object at 0xb7a3316c>
    u'\n  '
    <itools.xml.XML.Element object at 0xb7a331ac>
    u'\n    '
    <itools.xml.XML.Element object at 0xb7a332ac>
    u'\n    '
    <itools.xml.XML.Element object at 0xb7a331ec>
    u'Hello world'
    u'\n    '
    <itools.xml.XML.Comment object at 0xb7a335cc>
    u'\n  '
    u'\n  '
    <itools.xml.XML.Element object at 0xb798574c>
    u'\n  '
    u'\n'
\end{code}

Here we see the three kind of nodes currently supported: elements, comments
and text nodes.

\subsection{Elements}

Of the three kinds of nodes, elements are the most important and complex.
Element nodes give the tree structure, as they are the only ones that may
have children. If you inspect an element you will see the following
attributes:

\begin{api}
    {\tt namespace}\\
    - The XML namespace of the element (it will be None for a bare element).

    {\tt prefix}\\
    - The prefix used for the element's XML namespace.

    {\tt name}\\
    - The name of the element.

    {\tt attributes}\\
    - A dictionary mapping from the tuple XML namespace and local name to
      the attributes value.

    {\tt prefixes}\\
    - A mapping from XML namespace to prefix (used to get the qualified
      name of an attribute).

    {\tt children}\\
    - A list with the children of the element (elements, comments and text
      nodes).
\end{api}


And here is the API:

\begin{api}
    {\tt get\_qname()}\\
    - Returns the qualified name of the element.

    {\tt copy()}\\
    - Returns a clone of the element.

    {\tt set\_attribute(namespace, local\_name, value, prefix=None)}\\
    - Sets the given attribute.

    {\tt get\_attribute(namespace, local\_name)}\\
    - Returns the attribute value for the given XML namespace and local name.

    {\tt has\_attribute(namespace, local\_name)}\\
    - Returns a boolean value, true if the element contains a value for the
      given XML namespace and local name, false otherwise.

    {\tt get\_attributes()}
    - Is a generator that returns a three value tuple each time, the values
      are: XML namespace uri, local name, value.

    {\tt get\_attribute\_qname(namespace, local\_name)}\\
    - Returns the qualified name for the given XML namespace and local name.

    {\tt set\_element(element)}\\
    - Appends the given element to the list of children.

    {\tt set\_comment(comment)}\\
    - Appends the given comment to the list of children.

    {\tt set\_text(text)}\\
    - Appends the given text node (a unicode value) to the list of children.

    {\tt get\_elements(name=None)}\\
    - Returns a list with all the element nodes whose name is the given
    name; if the parameter {\tt name} is not given, then return all the
    element nodes.

    {\tt traverse()}\\
    - A generator that traverses the element's children in pre-order, and
      returns each time a node.

    {\tt traverse2()}\\
    - A more powerful version of {\tt traverse}.
\end{api}


\section{XHTML}

To finish the chapter we are going to give a glance to the implementation
of XHTML provided by {\tt itools.xhtml}.

To drive the explanation here is the document source we will use as example
(see {\tt examples/hello.xhtml}):

\begin{code}
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
           "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml">
      <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Hello world</title>
        <!-- Changed by: , 02-Jun-2004 -->
      </head>
      <body>
      </body>
    </html>
\end{code}

The only two differences between this file and the example we saw at the
beginning ({\tt examples/chapter8/hello.xml}) are the {\em document type}
declaration and the XML namespace declaration. The result is {\tt get\_handler}
returns an XHTML document instead of an XML document:

\begin{code}
    >>> doc = get_handler('examples/hello.xhtml')
    >>> doc
    <itools.xhtml.XHTML.Document object at 0xb7a2ec4c>
    >>> 
    >>> for node in doc.traverse():
    ...     print repr(node)
    ... 
    <itools.xhtml.XHTML.BlockElement object at 0xb79884ec>
    u'\n  '
    <itools.xhtml.XHTML.HeadElement object at 0xb798852c>
    u'\n    \n    '
    <itools.xhtml.XHTML.BlockElement object at 0xb79885ac>
    u'Hello world'
    u'\n    '
    <itools.xml.XML.Comment object at 0xb798856c>
    u'\n  '
    u'\n  '
    <itools.xhtml.XHTML.BlockElement object at 0xb798858c>
    u'\n  '
    u'\n'
\end{code}

Now, the element nodes are not any more instances of {\tt XML.Element}, but
instances of {\tt XHTML.Element}, which extends the generic API with the
methods:

\begin{api}
    {\tt is\_inline()}\\
    - Returns {\tt True} if the element is an inline element, {\tt False}
    otherwise.

    {\tt is\_block()}\\
    - Returns {\tt True} if the element is a block element, {\tt False}
    otherwise.
\end{api}

Ok, not too much\footnote{These two methods, {\tt is\_inline} and
{\tt is\_block}, are actually really useful. They are used by the message
extraction algorithm, a fundamental brick of the internationalization and
localization services provided by {\tt itools}.}, but enough to give an
idea of the power of {\tt itools.xml}. In the next chapter we will see a
much more compelling example of what can be done with {\tt itools.xml},
the {\bf S}imple {\bf T}emplate {\bf L}anguage.


